{"version":3,"file":"isotope.min.js","sources":["../src/node.ts","../src/nodes/conditional.ts","../src/configurators/attribs.ts","../src/configurators/classes.ts","../src/configurators/styles.ts","../src/utils.ts","../src/nodes/map.ts","../src/nodes/text.ts","../src/nodes/html/register.ts","../src/nodes/html/content.ts","../src/nodes/html/embed.ts","../src/nodes/html/form.ts","../src/nodes/html/interactive.ts","../src/nodes/html/media.ts","../src/nodes/html/section.ts","../src/nodes/html/table.ts","../src/nodes/html/text.ts","../src/view.ts"],"sourcesContent":["import { CustomDOM, CustomElement, Indexable } from \"./declarations\";\n\ninterface IsotopeNodeConfig<S extends Indexable, C extends Indexable> {\n\tnamespace?: string;\n\tautoLink?: boolean;\n\tattach?: boolean;\n\tcontext?: C;\n\tstate?: S;\n}\n\ninterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\tonCreate: Array<(node: this, config: IsotopeNodeConfig<S, C>) => void>;\n\tonProcess: Array<(node: this) => void>;\n\tonClean: Array<(node: this) => void>;\n\tcustomDOM?: CustomDOM | null;\n}\n\ntype Directive<S extends Indexable, C extends Indexable, R extends void | any> = (\n\tnode: IsotopeNode<S, C>\n) => R;\n\n/**\n * Class representing a Node.\n */\nclass IsotopeNode<S extends Indexable = any, C extends Indexable = any>\n\timplements IsotopeNode<S, C> {\n\tpublic state?: S;\n\n\tpublic context?: C;\n\n\tpublic id?: string;\n\n\tpublic linked?: IsotopeNode[] | null;\n\n\tpublic element: CustomElement;\n\n\tprotected linkup?: IsotopeNode | null;\n\n\tprotected childIndex?: number;\n\n\tprotected autoLink?: boolean;\n\n\tprotected listenedEvents?: string[];\n\n\t/**\n\t * Creates a new Node.\n\t *\n\t * @param element -  The Node's HTML element or tag.\n\t * @param config - The Node's configuration.\n\t */\n\tpublic constructor(\n\t\telement: string | CustomElement | Element,\n\t\tconfig?:\n\t\t\t| IsotopeNodeConfig<S, C>\n\t\t\t| string\n\t\t\t| Directive<S, C, void>\n\t\t\t| Array<Directive<S, C, void>>\n\t) {\n\t\tthis.element = this.getElement(element, config);\n\n\t\tif (typeof config === \"string\") {\n\t\t\tthis.element.textContent = config;\n\t\t} else if (typeof config === \"object\" && !Array.isArray(config)) {\n\t\t\tif (config.attach) {\n\t\t\t\tthis.childIndex = 0;\n\t\t\t}\n\n\t\t\tif (config.autoLink) {\n\t\t\t\tthis.autoLink = config.autoLink;\n\t\t\t}\n\n\t\t\tif (config.state) {\n\t\t\t\tthis.state = config.state;\n\t\t\t}\n\n\t\t\tif (config.context) {\n\t\t\t\tthis.context = config.context;\n\t\t\t}\n\n\t\t\tthis.onCreate.forEach((callback) => {\n\t\t\t\tcallback(this, config);\n\t\t\t});\n\t\t} else if (config) {\n\t\t\tthis.$(config);\n\t\t}\n\n\t\tthis.process();\n\t}\n\n\t/**\n\t * Executes the provided directive(s).\n\t *\n\t * @param directives - Directive(s) to be executed.\n\t * @returns - The Node or the return value of the directive.\n\t */\n\tpublic $<R extends void | any>(\n\t\tdirectives: Directive<S, C, R> | Array<Directive<S, C, void>>\n\t): R extends void ? this : R {\n\t\tif (Array.isArray(directives)) {\n\t\t\tdirectives.forEach((directive) => {\n\t\t\t\tdirective(this);\n\t\t\t});\n\t\t} else {\n\t\t\tconst value = directives(this);\n\n\t\t\tif (typeof value !== \"undefined\") {\n\t\t\t\treturn value as R extends void ? this : R;\n\t\t\t}\n\t\t}\n\n\t\treturn this as R extends void ? this : R;\n\t}\n\n\t/**\n\t * Adds a child Node to the Node.\n\t *\n\t * @param tag - Child Node's HTML tag.\n\t * @param config - Child Node's configuration.\n\t * @returns - The created child Node.\n\t */\n\tpublic child<S2 extends Indexable = Indexable, C2 extends Indexable = Indexable>(\n\t\ttag: string,\n\t\tconfig?:\n\t\t\t| IsotopeNodeConfig<S2, Partial<C> & C2>\n\t\t\t| string\n\t\t\t| Directive<S2, Partial<C> & C2, void>\n\t\t\t| Array<Directive<S2, Partial<C> & C2, void>>\n\t): IsotopeNode<S2, Partial<C> & C2> {\n\t\tconst shouldAttach = typeof this.childIndex !== \"undefined\";\n\n\t\tlet element: CustomElement | Element | string = tag;\n\n\t\tif (shouldAttach) {\n\t\t\tconst attachTarget = this.element.children[this.childIndex || 0];\n\n\t\t\tif (attachTarget) {\n\t\t\t\telement = attachTarget;\n\t\t\t\tthis.childIndex = (this.childIndex || 0) + 1;\n\t\t\t}\n\t\t}\n\n\t\tconst node = new IsotopeNode<S2, Partial<C> & C2>(element, config);\n\n\t\tthis.element.appendChild(node.element);\n\n\t\tif (shouldAttach && !node.childIndex) {\n\t\t\tnode.childIndex = 0;\n\t\t}\n\n\t\tif (this.context) {\n\t\t\tif (node.context) {\n\t\t\t\tnode.context = Object.assign(node.context, this.context);\n\t\t\t} else {\n\t\t\t\tnode.context = this.context as C & C2;\n\t\t\t}\n\t\t}\n\n\t\tif (this.autoLink) {\n\t\t\tthis.link(node);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Cleans the Node's child tree.\n\t *\n\t * @returns - IsotopeNode.\n\t */\n\tpublic clean(): this {\n\t\tif (this.linked) {\n\t\t\tthis.linked = null;\n\t\t}\n\n\t\tthis.onClean.forEach((callback) => {\n\t\t\tcallback(this);\n\t\t});\n\t\tthis.element.textContent = \"\";\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Emits the specified event.\n\t *\n\t * @param event - Event to be emitted.\n\t * @param data - Data to be passed to the listening function.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic emit(event: string, data: object = {}): this {\n\t\tif (this.listenedEvents && this.listenedEvents.includes(event)) {\n\t\t\tthis.element.dispatchEvent(\n\t\t\t\tObject.assign(\n\t\t\t\t\tthis.customDOM ? this.customDOM.createEvent(event) : new Event(event),\n\t\t\t\t\tdata\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Retrieves the data from the Node's context.\n\t *\n\t * @param key - Data key to be retrieved.\n\t * @returns - The retrieved data.\n\t */\n\tpublic getContext<K extends keyof C>(key: K): C[K] | null {\n\t\treturn this.context ? this.context[key] : null;\n\t}\n\n\t/**\n\t * Retrieves the data from the Node's state.\n\t *\n\t * @param key - Data key to be retrieved.\n\t * @returns - The retrieved data.\n\t */\n\tpublic getState<K extends keyof S>(key: K): S[K] | null {\n\t\treturn this.state ? this.state[key] : null;\n\t}\n\n\t/**\n\t * Links the provided Node.\n\t *\n\t * @param node - Node to be linked.\n\t * @param position - Position to place Node at in the linked array.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic link(node: IsotopeNode, position?: number): this {\n\t\tconst nodeLinkup = node.linkup;\n\n\t\tif (nodeLinkup !== this) {\n\t\t\tif (nodeLinkup && nodeLinkup.linked) {\n\t\t\t\tnodeLinkup.linked.splice(nodeLinkup.linked.indexOf(node), 1);\n\t\t\t}\n\n\t\t\tif (!this.linked) {\n\t\t\t\tthis.linked = [];\n\t\t\t}\n\n\t\t\tif (position) {\n\t\t\t\tthis.linked.splice(position, 0, node);\n\t\t\t} else {\n\t\t\t\tthis.linked.push(node);\n\t\t\t}\n\n\t\t\tnode.linkup = this;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Moves the linked Node to the provided position.\n\t *\n\t * @param position - Position index to move the Node to.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic move(position: number): this {\n\t\tconst { linkup } = this;\n\n\t\tif (linkup && linkup.linked) {\n\t\t\tconst upperLinked = linkup.linked;\n\t\t\tconst [node] = upperLinked.splice(upperLinked.indexOf(this as any), 1);\n\n\t\t\tupperLinked.splice(position, 0, node);\n\n\t\t\tconst referenceNode = upperLinked[position + 1];\n\n\t\t\tlinkup.element.insertBefore(\n\t\t\t\tthis.element,\n\t\t\t\treferenceNode ? referenceNode.element : null\n\t\t\t);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Disables the specified event listener.\n\t *\n\t * @param event - Event to disable the listener for.\n\t * @param handler - Event handler to be disabled.\n\t * @param options - Event listening options.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic off<K extends keyof HTMLElementEventMap>(\n\t\tevent: K | string,\n\t\thandler: (ev: HTMLElementEventMap[K]) => any,\n\t\toptions?: boolean | EventListenerOptions\n\t): this;\n\n\t/** @private */\n\tpublic off(\n\t\tevent: string,\n\t\thandler: EventListenerOrEventListenerObject,\n\t\toptions?: boolean | EventListenerOptions\n\t): this {\n\t\tthis.element.removeEventListener(event, handler, options);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Setups an event listener for the specified event.\n\t *\n\t * @param event - Event to be listened to.\n\t * @param handler - Event handling function.\n\t * @param options - Event listening options.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic on<K extends keyof HTMLElementEventMap>(\n\t\tevent: K | string,\n\t\thandler: (data: HTMLElementEventMap[K]) => void,\n\t\toptions?: boolean | AddEventListenerOptions\n\t): this;\n\n\t/** @private */\n\tpublic on(\n\t\tevent: string,\n\t\thandler: EventListenerOrEventListenerObject,\n\t\toptions?: boolean | AddEventListenerOptions\n\t): this {\n\t\tthis.element.addEventListener(event, handler, options);\n\n\t\tif (this.listenedEvents) {\n\t\t\tthis.listenedEvents.push(event);\n\t\t} else {\n\t\t\tthis.listenedEvents = [event];\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes the Node.\n\t *\n\t * @returns - IsotopeNode.\n\t */\n\tpublic remove(): this {\n\t\tconst { linkup } = this;\n\n\t\tif (linkup && linkup.linked) {\n\t\t\tlinkup.linked.splice(linkup.linked.indexOf(this as any), 1);\n\t\t}\n\n\t\tif (this.linked) {\n\t\t\tthis.linked = null;\n\t\t}\n\n\t\tif (this.element.parentElement) {\n\t\t\tthis.element.parentElement.removeChild(this.element);\n\t\t}\n\n\t\tthis.emit(\"node-removed\");\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the Node's state.\n\t *\n\t * @param state - State object to be set.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic setState(state: Partial<S>): this {\n\t\tif (this.state) {\n\t\t\tObject.assign(this.state, state);\n\t\t\tthis.emit(\"state-changed\");\n\t\t\tthis.process();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stringifies Node's element.\n\t *\n\t * @returns - Stringified Node's element.\n\t */\n\tpublic toString(): string {\n\t\treturn `${this.element}`;\n\t}\n\n\t/**\n\t * Retrieves the proper element from Node's configuration.\n\t *\n\t * @param element -  The Node's element or tag.\n\t * @param config - The Node's configuration.\n\t * @returns - Retrieved element.\n\t */\n\tprotected getElement(\n\t\telement: string | CustomElement | Element,\n\t\tconfig?:\n\t\t\t| IsotopeNodeConfig<S, C>\n\t\t\t| string\n\t\t\t| Directive<S, C, void>\n\t\t\t| Array<Directive<S, C, void>>\n\t): CustomElement {\n\t\tif (typeof element === \"string\") {\n\t\t\tif (typeof config === \"object\" && !Array.isArray(config) && config.namespace) {\n\t\t\t\tif (this.customDOM) {\n\t\t\t\t\treturn this.customDOM.createElement(element, config.namespace);\n\t\t\t\t}\n\n\t\t\t\treturn (document.createElementNS(\n\t\t\t\t\tconfig.namespace,\n\t\t\t\t\telement\n\t\t\t\t) as any) as CustomElement;\n\t\t\t} else if (this.customDOM) {\n\t\t\t\treturn this.customDOM.createElement(element);\n\t\t\t}\n\n\t\t\treturn (document.createElement(element) as any) as CustomElement;\n\t\t}\n\n\t\treturn element as CustomElement;\n\t}\n\n\t/**\n\t * Processes and renders the Node.\n\t */\n\tprotected process(): void {\n\t\tthis.emit(\"node-updated\");\n\t\tthis.onProcess.forEach((callback) => {\n\t\t\tcallback(this);\n\t\t});\n\n\t\tif (this.linked) {\n\t\t\tthis.linked.forEach((linked) => {\n\t\t\t\tlinked.process();\n\t\t\t});\n\t\t}\n\t}\n}\n\nObject.assign(IsotopeNode.prototype, {\n\tonClean: [],\n\tonCreate: [],\n\tonProcess: []\n});\n\nexport { Directive, IsotopeNode, IsotopeNodeConfig };\n","import { Indexable } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\n\ninterface ConditionalData<S extends Indexable, C extends Indexable> {\n\tprevious?: boolean;\n\tcondition: keyof S | ((node: IsotopeNode<S, C>) => boolean);\n\tonTrue(node: IsotopeNode<S, C>): IsotopeNode | void;\n\tonFalse?(node: IsotopeNode<S, C>): IsotopeNode | void;\n}\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\tconditionalData?: ConditionalData<S, C> | null;\n\t\t/**\n\t\t * Conditionally renders the provided nodes.\n\t\t *\n\t\t * @param condition - Condition to be checked.\n\t\t * @param onTrue - Rendering function to be executed when condition is truthy.\n\t\t * @param onFalse - Rendering function to be executed when condition is falsy.\n\t\t * @returns - The Node.\n\t\t */\n\t\tif(\n\t\t\tcondition: boolean | keyof S | ((node: this) => boolean),\n\t\t\tonTrue: (node: this) => IsotopeNode | void,\n\t\t\tonFalse?: (node: this) => IsotopeNode | void\n\t\t): this;\n\t}\n}\n\nif (!IsotopeNode.prototype.if) {\n\t/**\n\t * Processes the provided Node's conditional child tree.\n\t *\n\t * @param node - Node to be processed.\n\t */\n\tconst processConditional = (node: IsotopeNode): void => {\n\t\tif (node.conditionalData) {\n\t\t\tconst data = node.conditionalData;\n\t\t\tconst { condition } = data;\n\t\t\tconst processedCondition = Boolean(\n\t\t\t\ttypeof condition === \"function\" ? condition(node) : node.getState(condition)\n\t\t\t);\n\n\t\t\tif (processedCondition !== data.previous) {\n\t\t\t\tnode.element.textContent = \"\";\n\t\t\t\tnode.linked = null;\n\n\t\t\t\tif (processedCondition) {\n\t\t\t\t\tdata.onTrue(node);\n\t\t\t\t} else if (data.onFalse) {\n\t\t\t\t\tdata.onFalse(node);\n\t\t\t\t}\n\n\t\t\t\tdata.previous = processedCondition;\n\t\t\t}\n\t\t}\n\t};\n\n\tIsotopeNode.prototype.onClean.push((node) => {\n\t\tif (node.conditionalData) {\n\t\t\tnode.conditionalData = null;\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.conditionalData) {\n\t\t\tprocessConditional(node);\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\tif(\n\t\t\tthis: IsotopeNode,\n\t\t\tcondition: boolean | string | ((node: IsotopeNode) => boolean),\n\t\t\tonTrue: (node: IsotopeNode) => IsotopeNode | void,\n\t\t\tonFalse?: (node: IsotopeNode) => IsotopeNode | void\n\t\t): IsotopeNode {\n\t\t\tthis.clean();\n\n\t\t\tif (typeof condition === \"boolean\") {\n\t\t\t\tif (condition) {\n\t\t\t\t\tonTrue(this);\n\t\t\t\t} else if (onFalse) {\n\t\t\t\t\tonFalse(this);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.conditionalData = {\n\t\t\t\t\tcondition,\n\t\t\t\t\tonFalse,\n\t\t\t\t\tonTrue\n\t\t\t\t};\n\t\t\t\tprocessConditional(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","import { ConfigFunction, Indexable } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\tattribs?: ConfigFunction<S, C, Indexable<string | boolean>>;\n\t\t/**\n\t\t * Retrieves the value of the specified attribute.\n\t\t *\n\t\t * @param attrib - Attribute to be retrieved.\n\t\t * @returns - The retrieved value.\n\t\t */\n\t\tgetAttrib(attrib: string): string | boolean | null;\n\t\t/**\n\t\t * Sets the value of the specified attribute.\n\t\t *\n\t\t * @param attrib - Attribute to be set.\n\t\t * @param value - Value to assigned.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tsetAttrib(attrib: string, value?: string | boolean): this;\n\t\t/**\n\t\t * Sets multiple attributes.\n\t\t *\n\t\t * @param attribs - Object with key-value pairs of attributes and their values.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tsetAttribs(attribs: Indexable): this;\n\t}\n\tinterface IsotopeNodeConfig<S extends Indexable, C extends Indexable> {\n\t\tattribs?: Indexable | ConfigFunction<S, C, Indexable>;\n\t}\n}\n\nif (!IsotopeNode.prototype.setAttribs) {\n\tIsotopeNode.prototype.onCreate.push((node, config) => {\n\t\tif (config.attribs) {\n\t\t\tif (typeof config.attribs === \"function\") {\n\t\t\t\tnode.attribs = config.attribs as ConfigFunction<\n\t\t\t\t\tany,\n\t\t\t\t\tany,\n\t\t\t\t\tIndexable<string | boolean>\n\t\t\t\t>;\n\t\t\t} else {\n\t\t\t\tnode.setAttribs(config.attribs);\n\t\t\t}\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.attribs) {\n\t\t\tnode.setAttribs(node.attribs(node));\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\tgetAttrib(this: IsotopeNode, attrib: string): string | boolean | null {\n\t\t\tconst value = this.element.getAttribute(attrib);\n\n\t\t\treturn value === \"\" ? true : value;\n\t\t},\n\t\t/** @private */\n\t\tsetAttrib(this: IsotopeNode, attrib: string, value?: string | boolean): IsotopeNode {\n\t\t\tif (value) {\n\t\t\t\tthis.element.setAttribute(attrib, value === true ? \"\" : value);\n\t\t\t} else {\n\t\t\t\tthis.element.removeAttribute(attrib);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t/** @private */\n\t\tsetAttribs(this: IsotopeNode, attribs: Indexable): IsotopeNode {\n\t\t\tObject.entries(attribs).forEach(([attrib, value]) => {\n\t\t\t\tthis.setAttrib(attrib, value);\n\t\t\t});\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","import { ConfigFunction, Indexable } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\tclasses?: ConfigFunction<S, C, string[] | Indexable<boolean>>;\n\t\t/**\n\t\t * Applies the specified CSS class name to the Node's element.\n\t\t *\n\t\t * @param className - CSS class name to be applied.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\taddClass(className: string): this;\n\t\t/**\n\t\t * Checks if the Node's element contains the specified CSS class name.\n\t\t *\n\t\t * @param className - CSS class name to be checked.\n\t\t * @returns - If the Node's element contains the specified CSS class name.\n\t\t */\n\t\thasClass(className: string): boolean;\n\t\t/**\n\t\t * Removes the specified CSS class name from the Node's element.\n\t\t *\n\t\t * @param className - CSS class name to be removed.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tremoveClass(className: string): this;\n\t\t/**\n\t\t * Sets multiple CSS class names.\n\t\t *\n\t\t * @param classes - Object or array with CSS class name to be set.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tsetClasses(classes: string[] | Indexable<boolean>): this;\n\t}\n\tinterface IsotopeNodeConfig<S extends Indexable, C extends Indexable> {\n\t\tclasses?:\n\t\t\t| string[]\n\t\t\t| Indexable<boolean>\n\t\t\t| ConfigFunction<S, C, Indexable<boolean> | string[]>;\n\t}\n}\n\nif (!IsotopeNode.prototype.setClasses) {\n\tIsotopeNode.prototype.onCreate.push((node, config) => {\n\t\tif (config.classes) {\n\t\t\tlet classes = \"\";\n\n\t\t\tif (typeof config.classes === \"function\") {\n\t\t\t\tnode.classes = config.classes;\n\t\t\t} else if (Array.isArray(config.classes)) {\n\t\t\t\tclasses = config.classes.join(\" \");\n\t\t\t} else {\n\t\t\t\tclasses = Object.entries(config.classes)\n\t\t\t\t\t.filter(([, apply]) => apply)\n\t\t\t\t\t.map(([name]) => name)\n\t\t\t\t\t.join(\" \");\n\t\t\t}\n\n\t\t\tif (classes) {\n\t\t\t\tnode.element.setAttribute(\"class\", classes);\n\t\t\t}\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.classes) {\n\t\t\tnode.setClasses(node.classes(node));\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\taddClass(this: IsotopeNode, className: string): IsotopeNode {\n\t\t\tthis.element.classList.add(className);\n\n\t\t\treturn this;\n\t\t},\n\t\t/** @private */\n\t\thasClass(this: IsotopeNode, className: string): boolean {\n\t\t\treturn this.element.classList.contains(className);\n\t\t},\n\t\t/** @private */\n\t\tremoveClass(this: IsotopeNode, className: string): IsotopeNode {\n\t\t\tthis.element.classList.remove(className);\n\n\t\t\treturn this;\n\t\t},\n\t\t/** @private */\n\t\tsetClasses(this: IsotopeNode, classes: string[] | Indexable<boolean>): IsotopeNode {\n\t\t\tif (Array.isArray(classes)) {\n\t\t\t\tclasses.forEach((className) => this.addClass(className));\n\t\t\t} else {\n\t\t\t\tObject.entries(classes).forEach(([className, value]) => {\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tthis.addClass(className);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.removeClass(className);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","import { ConfigFunction, Indexable, StyleProperties } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\tstyles?: ConfigFunction<S, C, StyleProperties>;\n\t\t/**\n\t\t * Retrieves the value of the specified style property.\n\t\t *\n\t\t * @param property - Property to be retrieved.\n\t\t * @returns - The retrieved value.\n\t\t */\n\t\tgetStyle<P extends keyof StyleProperties>(\n\t\t\tproperty: P\n\t\t): StyleProperties[P] | undefined;\n\t\t/**\n\t\t * Sets the specified style property.\n\t\t *\n\t\t * @param property - Property to be set.\n\t\t * @param value - Value to be assigned.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tsetStyle<P extends keyof StyleProperties>(\n\t\t\tproperty: P,\n\t\t\tvalue: StyleProperties[P]\n\t\t): this;\n\t\t/**\n\t\t * Sets multiple style properties.\n\t\t *\n\t\t * @param styles - Object with style properties to be set.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tsetStyles(this: IsotopeNode, styles: StyleProperties): this;\n\t}\n\tinterface IsotopeNodeConfig<S extends Indexable, C extends Indexable> {\n\t\tstyles?: StyleProperties | ConfigFunction<S, C, StyleProperties>;\n\t}\n}\n\nif (!IsotopeNode.prototype.setStyles) {\n\tIsotopeNode.prototype.onCreate.push((node, config) => {\n\t\tif (config.styles) {\n\t\t\tif (typeof config.styles === \"function\") {\n\t\t\t\tnode.styles = config.styles;\n\t\t\t} else {\n\t\t\t\tnode.setStyles(config.styles);\n\t\t\t}\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.styles) {\n\t\t\tnode.setStyles(node.styles(node));\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\tgetStyle<P extends keyof StyleProperties>(\n\t\t\tthis: IsotopeNode,\n\t\t\tproperty: P\n\t\t): StyleProperties[P] | undefined {\n\t\t\tconst { style } = this.element;\n\n\t\t\treturn style ? style[property] : style;\n\t\t},\n\t\t/** @private */\n\t\tsetStyle<P extends keyof StyleProperties>(\n\t\t\tthis: IsotopeNode,\n\t\t\tproperty: P,\n\t\t\tvalue: StyleProperties[P]\n\t\t): IsotopeNode {\n\t\t\tconst { style } = this.element;\n\n\t\t\tif (style) {\n\t\t\t\tstyle[property] = `${value}${typeof value === \"number\" ? \"px\" : \"\"}` as any;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\t\t/** @private */\n\t\tsetStyles(this: IsotopeNode, styles: StyleProperties): IsotopeNode {\n\t\t\tObject.entries(styles).forEach(\n\t\t\t\t([property, value]: [keyof StyleProperties, string | number]) => {\n\t\t\t\t\tthis.setStyle(property, value);\n\t\t\t\t}\n\t\t\t);\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","interface Change {\n\tid: SimpleItem;\n\titem?: Item;\n\tposition?: number;\n\ttype: \"add\" | \"remove\" | \"move\";\n}\n\ninterface DiffingData {\n\tchanges: Change[];\n\tindex: number;\n\tsource: SimpleItem[];\n\tsourceInput: Item[];\n\ttarget: SimpleItem[];\n\ttargetInput: Item[];\n}\n\ninterface MoveData {\n\tleft: SimpleItem | null;\n\tright: SimpleItem | null;\n}\n\ntype SimpleItem = string | number;\n\ntype Item = string | number | { id: string | number };\n\n/**\n * Creates the Diffing loop data object.\n *\n * @param sourceInput - Original, source Item array.\n * @param targetInput - Target Item array.\n * @returns - Diffing loop data object.\n */\nconst createData = (sourceInput: Item[], targetInput: Item[]): DiffingData => ({\n\tchanges: [],\n\tindex: 0,\n\tsource: sourceInput.map((item) => `${typeof item === \"object\" ? item.id : item}`),\n\tsourceInput,\n\ttarget: targetInput.map((item) => `${typeof item === \"object\" ? item.id : item}`),\n\ttargetInput\n});\n/**\n * Checks if the diffing loop should be run.\n *\n * @param data - Diffing loop data.\n * @returns - If the diffing loop should be run.\n */\nconst shouldLoop = ({ index, source, target }: DiffingData): boolean => {\n\treturn (\n\t\tsource.length > 0 &&\n\t\ttarget.length > 0 &&\n\t\t(index <= source.length || index <= target.length)\n\t);\n};\n/**\n * Trims the diffed arrays from both sides if edge items are equal.\n *\n * @param data - Diffing loop data.\n * @returns - If arrays were trimmed.\n */\nconst trim = ({ source, target }: DiffingData): boolean => {\n\tconst [sourceStart] = source;\n\tconst sourceEnd = source[source.length - 1];\n\tconst [targetStart] = target;\n\tconst targetEnd = target[target.length - 1];\n\n\tlet trimmed = false;\n\n\tif (sourceStart === targetStart) {\n\t\tsource.shift();\n\t\ttarget.shift();\n\t\ttrimmed = true;\n\t}\n\n\tif (sourceEnd === targetEnd) {\n\t\tsource.pop();\n\t\ttarget.pop();\n\t\ttrimmed = true;\n\t}\n\n\treturn trimmed;\n};\n/**\n * Detect whether the items should be moved to the opposite site of the array.\n *\n * @param data - Diffing loop data.\n * @returns - Which item should be moved to left and which to right.\n */\nconst prepareMove = ({ index, source, target }: DiffingData): MoveData => {\n\tconst sourceStart = source[index];\n\tconst sourceEnd = source[source.length - 1 - index];\n\tconst [targetStart] = target;\n\tconst targetEnd = target[target.length - 1];\n\tconst moveLeft = sourceEnd === targetStart;\n\tconst moveRight = sourceStart === targetEnd;\n\tconst itemToLeft = moveLeft ? source.splice(source.length - 1 - index, 1)[0] : null;\n\tconst itemToRight = moveRight ? source.splice(index, 1)[0] : null;\n\n\treturn {\n\t\tleft: itemToLeft,\n\t\tright: itemToRight\n\t};\n};\n/**\n * Move the specified items to the opposite site of the array.\n *\n * @param data - Diffing loop data.\n * @param itemToLeft - Item to be moved to the left end.\n * @param itemToRight - Item to be moved to the right end.\n */\nconst move = (\n\t{ changes, source }: DiffingData,\n\titemToLeft: SimpleItem | null,\n\titemToRight: SimpleItem | null\n): void => {\n\tif (itemToRight !== null) {\n\t\tsource.push(itemToRight);\n\t\tchanges.push({\n\t\t\tid: itemToRight,\n\t\t\ttype: \"move\"\n\t\t});\n\t}\n\n\tif (itemToLeft !== null) {\n\t\tsource.splice(0, 0, itemToLeft);\n\t\tchanges.push({\n\t\t\tid: itemToLeft,\n\t\t\ttype: \"move\"\n\t\t});\n\t}\n};\n/**\n * Adds the new items from diffed arrays.\n *\n * @param data - Diffing loop data.\n */\nconst add = ({ changes, target }: DiffingData): void => {\n\ttarget.splice(0).forEach((id) => {\n\t\tchanges.push({\n\t\t\tid,\n\t\t\ttype: \"add\"\n\t\t});\n\t});\n};\n/**\n * Removes the previous items from diffed arrays.\n *\n * @param data - Diffing loop data.\n */\nconst remove = ({ changes, source }: DiffingData): void => {\n\tsource.splice(0).forEach((id) => {\n\t\tchanges.push({\n\t\t\tid,\n\t\t\ttype: \"remove\"\n\t\t});\n\t});\n};\n/**\n * Fills the remaining data required by specific changes.\n *\n * @param data - Diffing loop data.\n */\nconst fill = ({ changes, targetInput }: DiffingData): void => {\n\tchanges.forEach((change) => {\n\t\tconst id = `${change.id}`;\n\t\tconst { type } = change;\n\n\t\tif (type === \"add\" || type === \"move\") {\n\t\t\tconst index = targetInput.findIndex((item) => {\n\t\t\t\treturn typeof item === \"object\" ? `${item.id}` === id : `${item}` === id;\n\t\t\t});\n\n\t\t\tif (type === \"add\") {\n\t\t\t\tchange.item = targetInput[index];\n\t\t\t}\n\n\t\t\tchange.position = index;\n\t\t}\n\t});\n};\n/**\n * Detects changes made between 2 Item arrays.\n *\n * @param sourceInput - Original, source Item array.\n * @param targetInput - Target Item array.\n * @returns - Changes that differ the second array from the first one.\n */\nconst detectChanges = (sourceInput: Item[], targetInput: Item[]): Change[] => {\n\tconst data = createData(sourceInput, targetInput);\n\n\twhile (shouldLoop(data)) {\n\t\tif (trim(data)) {\n\t\t\tdata.index = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst { left, right } = prepareMove(data);\n\n\t\tif (left !== null || right !== null) {\n\t\t\tmove(data, left, right);\n\t\t\tdata.index = 0;\n\t\t} else {\n\t\t\tdata.index += 1;\n\t\t}\n\t}\n\n\tadd(data);\n\tremove(data);\n\tfill(data);\n\n\treturn data.changes;\n};\n\nexport { detectChanges };\n","import { Indexable } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\nimport { detectChanges } from \"../utils\";\n\ninterface MapData<\n\tS extends Indexable,\n\tC extends Indexable,\n\tI extends MappableItem = MappableItem\n> {\n\titems: Exclude<Mappable<S, C, I>, any[]>;\n\tcreateItem(item: any, node: IsotopeNode<S, C>, index: number): IsotopeNode | void;\n}\n\ntype MappableItem = string | number | { id: string | number };\n\ntype Mappable<\n\tS extends Indexable,\n\tC extends Indexable,\n\tI extends MappableItem = MappableItem\n> = I[] | keyof S | ((node: IsotopeNode<S, C>) => I[]);\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\tmapData?: MapData<S, C> | null;\n\t\t/**\n\t\t * Maps the provided data to a rendered Nodes list.\n\t\t *\n\t\t * @param items - Items to be mapped.\n\t\t * @param createItem - Rendering function to be used to render mapped items.\n\t\t * @returns - The Node.\n\t\t */\n\t\tmap<I extends MappableItem>(\n\t\t\titems: Mappable<S, C, I>,\n\t\t\tcreateItem: (item: I, node: this, index: number) => IsotopeNode | void\n\t\t): this;\n\t}\n}\n\nif (!IsotopeNode.prototype.map) {\n\t/**\n\t * Handles Nodes map update.\n\t *\n\t * @param node - The parent Node.\n\t * @param items - New items to be mapped.\n\t */\n\tconst handleMapUpdate = (node: IsotopeNode, items: MappableItem[]): void => {\n\t\tconst data = node.mapData!;\n\t\tconst changes = detectChanges(\n\t\t\t(node.linked as Array<{ id: string | number }>) || [],\n\t\t\titems\n\t\t);\n\n\t\tchanges.forEach(({ id, item, position = 0, type }, index) => {\n\t\t\tif (type === \"add\") {\n\t\t\t\tconst child = data.createItem(item, node, index);\n\n\t\t\t\tif (child) {\n\t\t\t\t\tchild.id = `${id}`;\n\t\t\t\t\tnode.link(child, position);\n\t\t\t\t\tchild.move(position);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst child = node.linked!.find((linked) => linked.id === id);\n\n\t\t\t\tif (child) {\n\t\t\t\t\tif (type === \"remove\") {\n\t\t\t\t\t\tchild.remove();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchild.move(position);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Handles the Nodes map creation.\n\t *\n\t * @param node - The parent Node.\n\t * @param items - Items to be mapped.\n\t */\n\tconst handleMapCreation = (node: IsotopeNode, items: MappableItem[]): void => {\n\t\tconst data = node.mapData!;\n\n\t\titems.forEach((item, index) => {\n\t\t\tconst child = data.createItem(item, node, index);\n\n\t\t\tif (child) {\n\t\t\t\tchild.id = `${typeof item === \"object\" ? item.id : item}`;\n\t\t\t\tnode.link(child);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Processes the provided Node's map child tree.\n\t *\n\t * @param node - Node to be processed.\n\t */\n\tconst processMap = (node: IsotopeNode): void => {\n\t\tif (node.mapData) {\n\t\t\tconst data = node.mapData;\n\t\t\tconst items: MappableItem[] & { isotopeMapped?: boolean } =\n\t\t\t\ttypeof data.items === \"function\" ? data.items(node) : node.getState(data.items);\n\n\t\t\tif (!items.isotopeMapped) {\n\t\t\t\tif (items.length === 0) {\n\t\t\t\t\tnode.linked = [];\n\t\t\t\t\tnode.element.textContent = \"\";\n\t\t\t\t} else if (node.linked) {\n\t\t\t\t\thandleMapUpdate(node, items);\n\t\t\t\t} else {\n\t\t\t\t\thandleMapCreation(node, items);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\titems.isotopeMapped = true;\n\t\t}\n\t};\n\n\tIsotopeNode.prototype.onClean.push((node) => {\n\t\tif (node.mapData) {\n\t\t\tnode.mapData = null;\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.mapData) {\n\t\t\tprocessMap(node);\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\tmap(\n\t\t\tthis: IsotopeNode,\n\t\t\titems: Mappable<any, any>,\n\t\t\tcreateItem: (item: any, node: IsotopeNode, index: number) => IsotopeNode | void\n\t\t): IsotopeNode {\n\t\t\tthis.clean();\n\n\t\t\tif (Array.isArray(items)) {\n\t\t\t\titems.forEach((item, index) => {\n\t\t\t\t\tcreateItem(item, this, index);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.mapData = {\n\t\t\t\t\tcreateItem,\n\t\t\t\t\titems\n\t\t\t\t};\n\t\t\t\tprocessMap(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","import { Indexable } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\n\ntype TextData<S extends Indexable, C extends Indexable> = (\n\tnode: IsotopeNode<S, C>\n) => string;\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\ttextData?: TextData<S, C> | null;\n\t\t/**\n\t\t * Sets the Node's element text.\n\t\t *\n\t\t * @param text - Text to be set.\n\t\t * @returns - The Node.\n\t\t */\n\t\ttext(text: TextData<S, C> | string): this;\n\t}\n}\n\nif (!IsotopeNode.prototype.text) {\n\t/**\n\t * Processes the provided Node's text child tree.\n\t *\n\t * @param node - Node to be processed.\n\t */\n\tconst processText = (node: IsotopeNode): void => {\n\t\tif (node.textData) {\n\t\t\tconst data = node.textData(node);\n\n\t\t\tif (data !== node.element.textContent) {\n\t\t\t\tnode.element.textContent = data;\n\t\t\t}\n\t\t}\n\t};\n\n\tIsotopeNode.prototype.onClean.push((node) => {\n\t\tif (node.textData) {\n\t\t\tnode.textData = null;\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.textData) {\n\t\t\tprocessText(node);\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\ttext(this: IsotopeNode, text: TextData<any, any> | string): IsotopeNode {\n\t\t\tthis.clean();\n\n\t\t\tif (typeof text === \"function\") {\n\t\t\t\tthis.textData = text;\n\t\t\t\tprocessText(this);\n\t\t\t} else {\n\t\t\t\tthis.element.textContent = text;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","import { Directive, IsotopeNode, IsotopeNodeConfig } from \"../../node\";\nimport { Indexable } from \"../../declarations\";\n\ntype Child = <S extends Indexable = any, C extends Indexable = any>(\n\tconfig?:\n\t\t| IsotopeNodeConfig<S, C>\n\t\t| string\n\t\t| Directive<S, C, void>\n\t\t| Array<Directive<S, C, void>>\n) => IsotopeNode<S, C>;\n\n/**\n * Registers new Node child function.\n *\n * @param name - Name for the child.\n */\nconst registerChild = (name: string): void => {\n\t/** @private */\n\tif (!IsotopeNode.prototype[name as keyof typeof IsotopeNode.prototype]) {\n\t\tIsotopeNode.prototype[name as keyof typeof IsotopeNode.prototype] = function (\n\t\t\tthis: IsotopeNode,\n\t\t\tconfig?: IsotopeNodeConfig<any, any> | string\n\t\t) {\n\t\t\treturn this.child(name, config);\n\t\t};\n\t}\n};\n\nexport { Child, registerChild };\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tblockquote: Child;\n\t\tdd: Child;\n\t\tdiv: Child;\n\t\tdl: Child;\n\t\tdt: Child;\n\t\tfigcaption: Child;\n\t\tfigure: Child;\n\t\thr: Child;\n\t\tli: Child;\n\t\tmain: Child;\n\t\tol: Child;\n\t\tp: Child;\n\t\tpre: Child;\n\t\tul: Child;\n\t}\n}\n\nconst nodes = [\n\t\"blockquote\",\n\t\"dd\",\n\t\"div\",\n\t\"dl\",\n\t\"dt\",\n\t\"figcaption\",\n\t\"figure\",\n\t\"hr\",\n\t\"li\",\n\t\"main\",\n\t\"ol\",\n\t\"p\",\n\t\"pre\",\n\t\"ul\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tembed: Child;\n\t\tiframe: Child;\n\t\tobject: Child;\n\t\tparam: Child;\n\t\tpicture: Child;\n\t\tsource: Child;\n\t}\n}\n\nconst nodes = [\"embed\", \"iframe\", \"object\", \"param\", \"picture\", \"source\"];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tbutton: Child;\n\t\tdatalist: Child;\n\t\tfieldset: Child;\n\t\tform: Child;\n\t\tinput: Child;\n\t\tlabel: Child;\n\t\tlegend: Child;\n\t\tmeter: Child;\n\t\toptgroup: Child;\n\t\toption: Child;\n\t\toutput: Child;\n\t\tprogress: Child;\n\t\tselect: Child;\n\t\ttextarea: Child;\n\t}\n}\n\nconst nodes = [\n\t\"button\",\n\t\"datalist\",\n\t\"fieldset\",\n\t\"form\",\n\t\"input\",\n\t\"label\",\n\t\"legend\",\n\t\"meter\",\n\t\"optgroup\",\n\t\"option\",\n\t\"output\",\n\t\"progress\",\n\t\"select\",\n\t\"textarea\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tdetails: Child;\n\t\tdialog: Child;\n\t\tmenu: Child;\n\t\tsummary: Child;\n\t\tcanvas: Child;\n\t\tscript: Child;\n\t\tnoscript: Child;\n\t\tslot: Child;\n\t\ttemplate: Child;\n\t}\n}\n\nconst nodes = [\n\t\"details\",\n\t\"dialog\",\n\t\"menu\",\n\t\"summary\",\n\t\"canvas\",\n\t\"script\",\n\t\"noscript\",\n\t\"slot\",\n\t\"template\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tarea: Child;\n\t\taudio: Child;\n\t\timg: Child;\n\t\ttrack: Child;\n\t\tvideo: Child;\n\t}\n}\n\nconst nodes = [\"area\", \"audio\", \"img\", \"track\", \"video\"];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\taddress: Child;\n\t\tarticle: Child;\n\t\taside: Child;\n\t\tfooter: Child;\n\t\theader: Child;\n\t\th1: Child;\n\t\th2: Child;\n\t\th3: Child;\n\t\th4: Child;\n\t\th5: Child;\n\t\th6: Child;\n\t\thgroup: Child;\n\t\tmain: Child;\n\t\tnav: Child;\n\t\tsection: Child;\n\t}\n}\n\nconst nodes = [\n\t\"address\",\n\t\"article\",\n\t\"aside\",\n\t\"footer\",\n\t\"header\",\n\t\"h1\",\n\t\"h2\",\n\t\"h3\",\n\t\"h4\",\n\t\"h5\",\n\t\"h6\",\n\t\"hgroup\",\n\t\"main\",\n\t\"nav\",\n\t\"section\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tcaption: Child;\n\t\tcol: Child;\n\t\tcolgroup: Child;\n\t\ttable: Child;\n\t\ttbody: Child;\n\t\ttd: Child;\n\t\ttfoot: Child;\n\t\tth: Child;\n\t\tthead: Child;\n\t\ttr: Child;\n\t}\n}\n\nconst nodes = [\n\t\"caption\",\n\t\"col\",\n\t\"colgroup\",\n\t\"table\",\n\t\"tbody\",\n\t\"td\",\n\t\"tfoot\",\n\t\"th\",\n\t\"thead\",\n\t\"tr\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tdel: Child;\n\t\tins: Child;\n\t\ta: Child;\n\t\tabbr: Child;\n\t\tb: Child;\n\t\tbdi: Child;\n\t\tbdo: Child;\n\t\tbr: Child;\n\t\tcite: Child;\n\t\tcode: Child;\n\t\tdata: Child;\n\t\tdfn: Child;\n\t\tem: Child;\n\t\ti: Child;\n\t\tkbd: Child;\n\t\tmark: Child;\n\t\tq: Child;\n\t\trb: Child;\n\t\trp: Child;\n\t\trt: Child;\n\t\trtc: Child;\n\t\truby: Child;\n\t\ts: Child;\n\t\tsamp: Child;\n\t\tsmall: Child;\n\t\tspan: Child;\n\t\tstrong: Child;\n\t\tsub: Child;\n\t\tsup: Child;\n\t\ttime: Child;\n\t\tu: Child;\n\t\tvar: Child;\n\t\twbr: Child;\n\t}\n}\n\nconst nodes = [\n\t\"del\",\n\t\"ins\",\n\t\"a\",\n\t\"abbr\",\n\t\"b\",\n\t\"bdi\",\n\t\"bdo\",\n\t\"br\",\n\t\"cite\",\n\t\"code\",\n\t\"data\",\n\t\"dfn\",\n\t\"em\",\n\t\"i\",\n\t\"kbd\",\n\t\"mark\",\n\t\"q\",\n\t\"rb\",\n\t\"rp\",\n\t\"rt\",\n\t\"rtc\",\n\t\"ruby\",\n\t\"s\",\n\t\"samp\",\n\t\"small\",\n\t\"span\",\n\t\"strong\",\n\t\"sub\",\n\t\"sup\",\n\t\"time\",\n\t\"u\",\n\t\"var\",\n\t\"wbr\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { IsotopeNode } from \"./node\";\n\ninterface IsotopeViewConfig {\n\tattach?: boolean;\n\tclean?: boolean;\n}\n\n/**\n * Creates a DOM View.\n *\n * @param element - Element to append to.\n * @param config - DOM View config.\n * @returns - The created top-level Node.\n */\nconst createDOMView = (element: Element, config?: IsotopeViewConfig): IsotopeNode => {\n\tif (IsotopeNode.prototype.customDOM) {\n\t\tIsotopeNode.prototype.customDOM = null;\n\t}\n\n\tif (!config || (config && config.clean && !config.attach)) {\n\t\telement.textContent = \"\";\n\t}\n\n\treturn new IsotopeNode(element, config);\n};\n\nexport { createDOMView };\n"],"names":["IsotopeNode","[object Object]","element","config","this","getElement","textContent","Array","isArray","$","attach","childIndex","autoLink","state","context","onCreate","forEach","callback","process","directives","directive","value","tag","shouldAttach","attachTarget","children","node","appendChild","Object","assign","link","linked","onClean","event","data","listenedEvents","includes","dispatchEvent","customDOM","createEvent","Event","key","position","nodeLinkup","linkup","splice","indexOf","push","upperLinked","referenceNode","insertBefore","handler","options","removeEventListener","addEventListener","parentElement","removeChild","emit","namespace","createElement","document","createElementNS","onProcess","prototype","setAttribs","attribs","attrib","getAttribute","setAttribute","removeAttribute","entries","setAttrib","setClasses","classes","join","filter","apply","map","name","className","classList","add","contains","remove","addClass","removeClass","setStyles","styles","property","style","setStyle","if","processConditional","conditionalData","condition","processedCondition","Boolean","getState","previous","onTrue","onFalse","clean","shouldLoop","index","source","target","length","trim","sourceStart","sourceEnd","targetStart","targetEnd","trimmed","shift","pop","prepareMove","moveRight","left","right","move","changes","itemToLeft","itemToRight","id","type","handleMapUpdate","items","mapData","sourceInput","targetInput","item","createData","change","findIndex","fill","detectChanges","child","createItem","find","handleMapCreation","processMap","isotopeMapped","text","processText","textData","registerChild"],"mappings":"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,QAAS8D,IACdmE,EAAcnE,KCjBD,CAAC,OAAQ,QAAS,MAAO,QAAS,SAE1C9D,QAAS8D,IACdmE,EAAcnE,KCOD,CACb,UACA,UACA,QACA,SACA,SACA,KACA,KACA,KACA,KACA,KACA,KACA,SACA,OACA,MACA,WAGK9D,QAAS8D,IACdmE,EAAcnE,KCxBD,CACb,UACA,MACA,WACA,QACA,QACA,KACA,QACA,KACA,QACA,MAGK9D,QAAS8D,IACdmE,EAAcnE,KCSD,CACb,MACA,MACA,IACA,OACA,IACA,MACA,MACA,KACA,OACA,OACA,OACA,MACA,KACA,IACA,MACA,OACA,IACA,KACA,KACA,KACA,MACA,OACA,IACA,OACA,QACA,OACA,SACA,MACA,MACA,OACA,IACA,MACA,OAGK9D,QAAS8D,IACdmE,EAAcnE,qCC/DO,EAAC5E,EAAkBC,KACpCH,EAAY+D,UAAUzB,YACzBtC,EAAY+D,UAAUzB,UAAY,QAG9BnC,GAAWA,GAAUA,EAAOkG,QAAUlG,EAAOO,UACjDR,EAAQI,YAAc,IAGhB,IAAIN,EAAYE,EAASC"}