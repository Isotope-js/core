{"version":3,"file":"isotope.min.js","sources":["../src/node.ts","../src/views/string/element.ts","../src/nodes/conditional.ts","../src/configurators/attribs.ts","../src/configurators/classes.ts","../src/configurators/styles.ts","../src/utils.ts","../src/nodes/map.ts","../src/nodes/text.ts","../src/nodes/html/register.ts","../src/nodes/html/content.ts","../src/nodes/html/embed.ts","../src/nodes/html/form.ts","../src/nodes/html/interactive.ts","../src/nodes/html/media.ts","../src/nodes/html/section.ts","../src/nodes/html/table.ts","../src/nodes/html/text.ts","../src/views/dom.ts","../src/views/string/string.ts"],"sourcesContent":["import { CustomDOM, CustomElement, Indexable } from \"./declarations\";\r\n\r\ninterface IsotopeNodeConfig<S extends Indexable, C extends Indexable> {\r\n\tnamespace?: string;\r\n\tautoLink?: boolean;\r\n\tattach?: boolean;\r\n\tcontext?: C;\r\n\tstate?: S;\r\n}\r\n\r\ninterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\r\n\tonCreate: Array<(node: this, config: IsotopeNodeConfig<S, C>) => void>;\r\n\tonProcess: Array<(node: this) => void>;\r\n\tonClean: Array<(node: this) => void>;\r\n\tcustomDOM?: CustomDOM | null;\r\n}\r\n\r\ntype Directive<S extends Indexable, C extends Indexable, R extends void | IsotopeNode> = (\r\n\tnode: IsotopeNode<S, C>\r\n) => R;\r\n\r\n/**\r\n * Class representing a Node.\r\n */\r\nclass IsotopeNode<S extends Indexable = any, C extends Indexable = any>\r\n\timplements IsotopeNode<S, C> {\r\n\tpublic state?: S;\r\n\r\n\tpublic context?: C;\r\n\r\n\tpublic id?: string;\r\n\r\n\tpublic linked?: IsotopeNode[] | null;\r\n\r\n\tpublic element: CustomElement;\r\n\r\n\tprotected linkup?: IsotopeNode | null;\r\n\r\n\tprotected childIndex?: number;\r\n\r\n\tprotected autoLink?: boolean;\r\n\r\n\t/**\r\n\t * Creates a new Node.\r\n\t *\r\n\t * @param element -  The Node's HTML element or tag.\r\n\t * @param config - The Node's configuration.\r\n\t */\r\n\tpublic constructor(\r\n\t\telement: string | CustomElement | Element,\r\n\t\tconfig?: IsotopeNodeConfig<S, C> | string\r\n\t) {\r\n\t\tthis.element = this.getElement(element, config);\r\n\r\n\t\tif (typeof config === \"string\") {\r\n\t\t\tthis.element.textContent = config;\r\n\t\t} else if (config) {\r\n\t\t\tif (config.attach) {\r\n\t\t\t\tthis.childIndex = 0;\r\n\t\t\t}\r\n\r\n\t\t\tif (config.autoLink) {\r\n\t\t\t\tthis.autoLink = config.autoLink;\r\n\t\t\t}\r\n\r\n\t\t\tif (config.state) {\r\n\t\t\t\tthis.state = config.state;\r\n\t\t\t}\r\n\r\n\t\t\tif (config.context) {\r\n\t\t\t\tthis.context = config.context;\r\n\t\t\t}\r\n\r\n\t\t\tthis.onCreate.forEach((callback) => {\r\n\t\t\t\tcallback(this, config);\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tthis.process();\r\n\t}\r\n\r\n\t/**\r\n\t * Executes the provided directive(s).\r\n\t *\r\n\t * @param directives - Directive(s) to be executed.\r\n\t * @returns - The Node.\r\n\t */\r\n\tpublic $<R extends void | IsotopeNode>(\r\n\t\tdirectives: Directive<S, C, R> | Array<Directive<S, C, void>>\r\n\t): R extends void ? this : R {\r\n\t\tif (Array.isArray(directives)) {\r\n\t\t\tdirectives.forEach((directive) => {\r\n\t\t\t\tdirective(this);\r\n\t\t\t});\r\n\t\t} else {\r\n\t\t\tconst node = directives(this);\r\n\r\n\t\t\tif (node) {\r\n\t\t\t\treturn node as R extends void ? this : R;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\treturn this as R extends void ? this : R;\r\n\t}\r\n\r\n\t/**\r\n\t * Adds a child Node to the Node.\r\n\t *\r\n\t * @param tag - Child Node's HTML tag.\r\n\t * @param config - Child Node's configuration.\r\n\t * @returns - The created child Node.\r\n\t */\r\n\tpublic child<S2 extends Indexable = Indexable, C2 extends Indexable = Indexable>(\r\n\t\ttag: string,\r\n\t\tconfig?: IsotopeNodeConfig<S2, Partial<C> & C2> | string\r\n\t): IsotopeNode<S2, Partial<C> & C2> {\r\n\t\tconst shouldAttach = typeof this.childIndex !== \"undefined\";\r\n\r\n\t\tlet element: CustomElement | Element | string = tag;\r\n\r\n\t\tif (shouldAttach) {\r\n\t\t\tconst attachTarget = this.element.children[this.childIndex || 0];\r\n\r\n\t\t\tif (attachTarget) {\r\n\t\t\t\telement = attachTarget;\r\n\t\t\t\tthis.childIndex = (this.childIndex || 0) + 1;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tconst node = new IsotopeNode<S2, Partial<C> & C2>(element, config);\r\n\r\n\t\tthis.element.appendChild(node.element);\r\n\r\n\t\tif (shouldAttach && !node.childIndex) {\r\n\t\t\tnode.childIndex = 0;\r\n\t\t}\r\n\r\n\t\tif (this.context) {\r\n\t\t\tif (node.context) {\r\n\t\t\t\tnode.context = Object.assign(node.context, this.context);\r\n\t\t\t} else {\r\n\t\t\t\tnode.context = this.context as C & C2;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (this.autoLink) {\r\n\t\t\tthis.link(node);\r\n\t\t}\r\n\r\n\t\treturn node;\r\n\t}\r\n\r\n\t/**\r\n\t * Cleans the Node's child tree.\r\n\t *\r\n\t * @returns - IsotopeNode.\r\n\t */\r\n\tpublic clean(): this {\r\n\t\tif (this.linked) {\r\n\t\t\tthis.linked = null;\r\n\t\t}\r\n\r\n\t\tthis.onClean.forEach((callback) => {\r\n\t\t\tcallback(this);\r\n\t\t});\r\n\t\tthis.element.textContent = \"\";\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Emits the specified event.\r\n\t *\r\n\t * @param event - Event to be emitted.\r\n\t * @param data - Data to be passed to the listening function.\r\n\t * @returns - IsotopeNode.\r\n\t */\r\n\tpublic emit(event: string, data: object = {}): this {\r\n\t\tthis.element.dispatchEvent(\r\n\t\t\tObject.assign(\r\n\t\t\t\tthis.customDOM ? this.customDOM.createEvent(event) : new Event(event),\r\n\t\t\t\t{ node: this },\r\n\t\t\t\tdata\r\n\t\t\t)\r\n\t\t);\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Retrieves the data from the Node's context.\r\n\t *\r\n\t * @param key - Data key to be retrieved.\r\n\t * @returns - The retrieved data.\r\n\t */\r\n\tpublic getContext<K extends keyof C>(key: K): C[K] | null {\r\n\t\treturn this.context ? this.context[key] : null;\r\n\t}\r\n\r\n\t/**\r\n\t * Retrieves the data from the Node's state.\r\n\t *\r\n\t * @param key - Data key to be retrieved.\r\n\t * @returns - The retrieved data.\r\n\t */\r\n\tpublic getState<K extends keyof S>(key: K): S[K] | null {\r\n\t\treturn this.state ? this.state[key] : null;\r\n\t}\r\n\r\n\t/**\r\n\t * Links the provided Node.\r\n\t *\r\n\t * @param node - Node to be linked.\r\n\t * @param position - Position to place Node at in the linked array.\r\n\t * @returns - IsotopeNode.\r\n\t */\r\n\tpublic link(node: IsotopeNode, position?: number): this {\r\n\t\tconst nodeLinkup = node.linkup;\r\n\r\n\t\tif (nodeLinkup !== this) {\r\n\t\t\tif (nodeLinkup && nodeLinkup.linked) {\r\n\t\t\t\tnodeLinkup.linked.splice(nodeLinkup.linked.indexOf(node), 1);\r\n\t\t\t}\r\n\r\n\t\t\tif (!this.linked) {\r\n\t\t\t\tthis.linked = [];\r\n\t\t\t}\r\n\r\n\t\t\tif (position) {\r\n\t\t\t\tthis.linked.splice(position, 0, node);\r\n\t\t\t} else {\r\n\t\t\t\tthis.linked.push(node);\r\n\t\t\t}\r\n\r\n\t\t\tnode.linkup = this;\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Moves the linked Node to the provided position.\r\n\t *\r\n\t * @param position - Position index to move the Node to.\r\n\t * @returns - IsotopeNode.\r\n\t */\r\n\tpublic move(position: number): this {\r\n\t\tconst { linkup } = this;\r\n\r\n\t\tif (linkup && linkup.linked) {\r\n\t\t\tconst upperLinked = linkup.linked;\r\n\t\t\tconst [node] = upperLinked.splice(upperLinked.indexOf(this as any), 1);\r\n\r\n\t\t\tupperLinked.splice(position, 0, node);\r\n\r\n\t\t\tconst referenceNode = upperLinked[position + 1];\r\n\r\n\t\t\tlinkup.element.insertBefore(\r\n\t\t\t\tthis.element,\r\n\t\t\t\treferenceNode ? referenceNode.element : null\r\n\t\t\t);\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Disables the specified event listener.\r\n\t *\r\n\t * @param event - Event to disable the listener for.\r\n\t * @param handler - Event handler to be disabled.\r\n\t * @param options - Event listening options.\r\n\t * @returns - IsotopeNode.\r\n\t */\r\n\tpublic off<K extends keyof HTMLElementEventMap>(\r\n\t\tevent: K | string,\r\n\t\thandler: (ev: HTMLElementEventMap[K]) => any,\r\n\t\toptions?: boolean | EventListenerOptions\r\n\t): this;\r\n\r\n\t/** @private */\r\n\tpublic off(\r\n\t\tevent: string,\r\n\t\thandler: EventListenerOrEventListenerObject,\r\n\t\toptions?: boolean | EventListenerOptions\r\n\t): this {\r\n\t\tthis.element.removeEventListener(event, handler, options);\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Setups an event listener for the specified event.\r\n\t *\r\n\t * @param event - Event to be listened to.\r\n\t * @param handler - Event handling function.\r\n\t * @param options - Event listening options.\r\n\t * @returns - IsotopeNode.\r\n\t */\r\n\tpublic on<K extends keyof HTMLElementEventMap>(\r\n\t\tevent: K | string,\r\n\t\thandler: (data: HTMLElementEventMap[K]) => void,\r\n\t\toptions?: boolean | AddEventListenerOptions\r\n\t): this;\r\n\r\n\t/** @private */\r\n\tpublic on(\r\n\t\tevent: string,\r\n\t\thandler: EventListenerOrEventListenerObject,\r\n\t\toptions?: boolean | AddEventListenerOptions\r\n\t): this {\r\n\t\tthis.element.addEventListener(event, handler, options);\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Removes the Node.\r\n\t *\r\n\t * @returns - IsotopeNode.\r\n\t */\r\n\tpublic remove(): this {\r\n\t\tconst { linkup } = this;\r\n\r\n\t\tif (linkup && linkup.linked) {\r\n\t\t\tlinkup.linked.splice(linkup.linked.indexOf(this as any), 1);\r\n\t\t}\r\n\r\n\t\tif (this.linked) {\r\n\t\t\tthis.linked = null;\r\n\t\t}\r\n\r\n\t\tif (this.element.parentElement) {\r\n\t\t\tthis.element.parentElement.removeChild(this.element);\r\n\t\t}\r\n\r\n\t\tthis.emit(\"node-removed\");\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Sets the Node's state.\r\n\t *\r\n\t * @param state - State object to be set.\r\n\t * @returns - IsotopeNode.\r\n\t */\r\n\tpublic setState(state: Partial<S>): this {\r\n\t\tif (this.state) {\r\n\t\t\tObject.assign(this.state, state);\r\n\t\t\tthis.emit(\"state-changed\");\r\n\t\t\tthis.process();\r\n\t\t}\r\n\r\n\t\treturn this;\r\n\t}\r\n\r\n\t/**\r\n\t * Stringifies Node's element.\r\n\t *\r\n\t * @returns - Stringified Node's element.\r\n\t */\r\n\tpublic toString(): string {\r\n\t\treturn `${this.element}`;\r\n\t}\r\n\r\n\t/**\r\n\t * Retrieves the proper element from Node's configuration.\r\n\t *\r\n\t * @param element -  The Node's element or tag.\r\n\t * @param config - The Node's configuration.\r\n\t * @returns - Retrieved element.\r\n\t */\r\n\tprotected getElement(\r\n\t\telement: string | CustomElement | Element,\r\n\t\tconfig?: IsotopeNodeConfig<S, C> | string\r\n\t): CustomElement {\r\n\t\tif (typeof element === \"string\") {\r\n\t\t\tif (typeof config === \"object\" && config.namespace) {\r\n\t\t\t\tif (this.customDOM) {\r\n\t\t\t\t\treturn this.customDOM.createElement(element, config.namespace);\r\n\t\t\t\t}\r\n\r\n\t\t\t\treturn (document.createElementNS(\r\n\t\t\t\t\tconfig.namespace,\r\n\t\t\t\t\telement\r\n\t\t\t\t) as any) as CustomElement;\r\n\t\t\t} else if (this.customDOM) {\r\n\t\t\t\treturn this.customDOM.createElement(element);\r\n\t\t\t}\r\n\r\n\t\t\treturn (document.createElement(element) as any) as CustomElement;\r\n\t\t}\r\n\r\n\t\treturn element as CustomElement;\r\n\t}\r\n\r\n\t/**\r\n\t * Processes and renders the Node.\r\n\t */\r\n\tprotected process(): void {\r\n\t\tthis.emit(\"node-updated\");\r\n\t\tthis.onProcess.forEach((callback) => {\r\n\t\t\tcallback(this);\r\n\t\t});\r\n\r\n\t\tif (this.linked) {\r\n\t\t\tthis.linked.forEach((linked) => {\r\n\t\t\t\tlinked.process();\r\n\t\t\t});\r\n\t\t}\r\n\t}\r\n}\r\n\r\nObject.assign(IsotopeNode.prototype, {\r\n\tonClean: [],\r\n\tonCreate: [],\r\n\tonProcess: []\r\n});\r\n\r\nexport { IsotopeNode, IsotopeNodeConfig };\r\n","/* eslint-disable @typescript-eslint/no-empty-function */\r\nimport { CustomElement, Indexable } from \"../../declarations\";\r\nimport { Properties } from \"csstype\";\r\n\r\n/**\r\n * Class implementing Isotope CustomElement API, allowing for easy server-side stringification.\r\n */\r\nclass StringElement implements CustomElement {\r\n\tpublic children: StringElement[] = [];\r\n\r\n\tpublic classList = {\r\n\t\tadd: (...tokens: string[]): void => {\r\n\t\t\tthis.classes.push(...tokens);\r\n\t\t},\r\n\t\tcontains: (token: string): boolean => {\r\n\t\t\treturn this.classes.includes(token);\r\n\t\t},\r\n\t\tremove: (...tokens: string[]): void => {\r\n\t\t\ttokens.forEach((token) => {\r\n\t\t\t\tthis.classes.splice(this.classes.indexOf(token), 1);\r\n\t\t\t});\r\n\t\t}\r\n\t};\r\n\r\n\tpublic parentElement: StringElement | null = null;\r\n\r\n\tpublic style: Properties<string> = {};\r\n\r\n\tpublic tagName: string;\r\n\r\n\tprotected attributes: { [name: string]: string | null } = {};\r\n\r\n\tprotected classes: string[] = [];\r\n\r\n\tprivate $textContent: string | null = \"\";\r\n\r\n\tprivate events: Indexable<EventListenerOrEventListenerObject[]> = {};\r\n\r\n\t/**\r\n\t * Creates a new ServerElement instance.\r\n\t *\r\n\t * @param tag - Tag to be used for the element.\r\n\t */\r\n\tpublic constructor(tag: string) {\r\n\t\tthis.tagName = tag;\r\n\t}\r\n\r\n\t/** @private */\r\n\tpublic addEventListener(\r\n\t\ttype: string,\r\n\t\tlistener: EventListenerOrEventListenerObject\r\n\t): void {\r\n\t\t(this.events[type] || (this.events[type] = [])).push(listener);\r\n\t}\r\n\r\n\t/** @private */\r\n\tpublic appendChild(newChild: StringElement): StringElement {\r\n\t\tthis.children.push(newChild);\r\n\t\tnewChild.parentElement = this;\r\n\r\n\t\treturn newChild;\r\n\t}\r\n\r\n\t/** @private */\r\n\tpublic dispatchEvent(event: CustomEvent): boolean {\r\n\t\t(this.events[event.type] || []).slice().forEach((handler) => {\r\n\t\t\tif (typeof handler === \"function\") {\r\n\t\t\t\thandler(event);\r\n\t\t\t} else {\r\n\t\t\t\thandler.handleEvent(event);\r\n\t\t\t}\r\n\t\t});\r\n\r\n\t\treturn true;\r\n\t}\r\n\r\n\t/** @private */\r\n\tpublic getAttribute(qualifiedName: string): string | null {\r\n\t\treturn this.attributes[qualifiedName];\r\n\t}\r\n\r\n\t/** @private */\r\n\tpublic insertBefore(\r\n\t\tnewChild: StringElement,\r\n\t\trefChild: StringElement | null\r\n\t): StringElement {\r\n\t\tnewChild.parentElement = this;\r\n\r\n\t\tif (refChild) {\r\n\t\t\tconst index = this.children.indexOf(refChild);\r\n\r\n\t\t\tif (index >= 0) {\r\n\t\t\t\tthis.children.splice(index + 1, 0, newChild);\r\n\r\n\t\t\t\treturn newChild;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tthis.children.push(newChild);\r\n\r\n\t\treturn newChild;\r\n\t}\r\n\r\n\t/** @private */\r\n\tpublic removeAttribute(qualifiedName: string): void {\r\n\t\tthis.attributes[qualifiedName] = null;\r\n\t}\r\n\r\n\t/** @private */\r\n\tpublic removeChild(oldChild: StringElement): StringElement {\r\n\t\toldChild.parentElement = null;\r\n\t\tthis.children.splice(this.children.indexOf(oldChild), 1);\r\n\r\n\t\treturn oldChild;\r\n\t}\r\n\r\n\t/** @private */\r\n\tpublic removeEventListener(\r\n\t\ttype: string,\r\n\t\tlistener: EventListenerOrEventListenerObject\r\n\t): void {\r\n\t\tif (this.events[type]) {\r\n\t\t\tthis.events[type].splice(this.events[type].indexOf(listener) >>> 0, 1);\r\n\t\t}\r\n\t}\r\n\r\n\t/** @private */\r\n\tpublic setAttribute(qualifiedName: string, value: string): void {\r\n\t\tthis.attributes[qualifiedName] = value;\r\n\t}\r\n\r\n\t/** @private */\r\n\tpublic set textContent(textContent: string | null) {\r\n\t\tthis.children = [];\r\n\t\tthis.$textContent = textContent || \"\";\r\n\t}\r\n\r\n\t/** @private */\r\n\tpublic get textContent(): string | null {\r\n\t\treturn this.$textContent;\r\n\t}\r\n\r\n\t/**\r\n\t * Stringifies the ServerElement.\r\n\t *\r\n\t * @returns - Stringified ServerElement.\r\n\t */\r\n\tpublic toString(): string {\r\n\t\tconst tag = this.tagName;\r\n\t\tconst content =\r\n\t\t\tthis.textContent ||\r\n\t\t\tthis.children\r\n\t\t\t\t.map((child) => {\r\n\t\t\t\t\treturn `${child}`;\r\n\t\t\t\t})\r\n\t\t\t\t.join(\"\");\r\n\t\tconst classes = this.classes.join(\" \");\r\n\t\tconst styles = Object.entries(this.style)\r\n\t\t\t.map(([property, value]) => {\r\n\t\t\t\tconst propertyKebabCase = property.replace(\r\n\t\t\t\t\t/[A-Z]/g,\r\n\t\t\t\t\t(match) => `-${match.toLowerCase()}`\r\n\t\t\t\t);\r\n\r\n\t\t\t\treturn `${propertyKebabCase}:${value}`;\r\n\t\t\t})\r\n\t\t\t.join(\";\");\r\n\t\tconst attributes = Object.entries(this.attributes)\r\n\t\t\t.map(([name, value]) => {\r\n\t\t\t\treturn `${name}=\"${value}\"`;\r\n\t\t\t})\r\n\t\t\t.join(\" \");\r\n\r\n\t\treturn `<${tag}${classes ? ` class=\"${classes}\"` : \"\"}${\r\n\t\t\tstyles ? `style=\"${styles}\"` : \"\"\r\n\t\t}${attributes}>${content}</${tag}>`;\r\n\t}\r\n}\r\n\r\nexport { StringElement };\r\n","import { Indexable } from \"../declarations\";\r\nimport { IsotopeNode } from \"../node\";\r\n\r\ninterface ConditionalData<S extends Indexable, C extends Indexable> {\r\n\tprevious?: boolean;\r\n\tcondition: keyof S | ((node: IsotopeNode<S, C>) => boolean);\r\n\tonTrue(node: IsotopeNode<S, C>): IsotopeNode | void;\r\n\tonFalse?(node: IsotopeNode<S, C>): IsotopeNode | void;\r\n}\r\n\r\ndeclare module \"../node\" {\r\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\r\n\t\tconditionalData?: ConditionalData<S, C> | null;\r\n\t\t/**\r\n\t\t * Conditionally renders the provided nodes.\r\n\t\t *\r\n\t\t * @param condition - Condition to be checked.\r\n\t\t * @param onTrue - Rendering function to be executed when condition is truthy.\r\n\t\t * @param onFalse - Rendering function to be executed when condition is falsy.\r\n\t\t * @returns - The Node.\r\n\t\t */\r\n\t\tif(\r\n\t\t\tcondition: boolean | keyof S | ((node: this) => boolean),\r\n\t\t\tonTrue: (node: this) => IsotopeNode | void,\r\n\t\t\tonFalse?: (node: this) => IsotopeNode | void\r\n\t\t): this;\r\n\t}\r\n}\r\n\r\nif (!IsotopeNode.prototype.if) {\r\n\t/**\r\n\t * Processes the provided Node's conditional child tree.\r\n\t *\r\n\t * @param node - Node to be processed.\r\n\t */\r\n\tconst processConditional = (node: IsotopeNode): void => {\r\n\t\tif (node.conditionalData) {\r\n\t\t\tconst data = node.conditionalData;\r\n\t\t\tconst { condition } = data;\r\n\t\t\tconst processedCondition = Boolean(\r\n\t\t\t\ttypeof condition === \"function\" ? condition(node) : node.getState(condition)\r\n\t\t\t);\r\n\r\n\t\t\tif (processedCondition !== data.previous) {\r\n\t\t\t\tnode.element.textContent = \"\";\r\n\t\t\t\tnode.linked = null;\r\n\r\n\t\t\t\tif (processedCondition) {\r\n\t\t\t\t\tdata.onTrue(node);\r\n\t\t\t\t} else if (data.onFalse) {\r\n\t\t\t\t\tdata.onFalse(node);\r\n\t\t\t\t}\r\n\r\n\t\t\t\tdata.previous = processedCondition;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tIsotopeNode.prototype.onClean.push((node) => {\r\n\t\tif (node.conditionalData) {\r\n\t\t\tnode.conditionalData = null;\r\n\t\t}\r\n\t});\r\n\tIsotopeNode.prototype.onProcess.push((node) => {\r\n\t\tif (node.conditionalData) {\r\n\t\t\tprocessConditional(node);\r\n\t\t}\r\n\t});\r\n\tObject.assign(IsotopeNode.prototype, {\r\n\t\t/** @private */\r\n\t\tif(\r\n\t\t\tthis: IsotopeNode,\r\n\t\t\tcondition: boolean | string | ((node: IsotopeNode) => boolean),\r\n\t\t\tonTrue: (node: IsotopeNode) => IsotopeNode | void,\r\n\t\t\tonFalse?: (node: IsotopeNode) => IsotopeNode | void\r\n\t\t): IsotopeNode {\r\n\t\t\tthis.clean();\r\n\r\n\t\t\tif (typeof condition === \"boolean\") {\r\n\t\t\t\tif (condition) {\r\n\t\t\t\t\tonTrue(this);\r\n\t\t\t\t} else if (onFalse) {\r\n\t\t\t\t\tonFalse(this);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tthis.conditionalData = {\r\n\t\t\t\t\tcondition,\r\n\t\t\t\t\tonFalse,\r\n\t\t\t\t\tonTrue\r\n\t\t\t\t};\r\n\t\t\t\tprocessConditional(this);\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\t\t}\r\n\t});\r\n}\r\n","import { ConfigFunction, Indexable } from \"../declarations\";\r\nimport { IsotopeNode } from \"../node\";\r\n\r\ndeclare module \"../node\" {\r\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\r\n\t\tattribs?: ConfigFunction<S, C, Indexable<string | boolean>>;\r\n\t\t/**\r\n\t\t * Retrieves the value of the specified attribute.\r\n\t\t *\r\n\t\t * @param attrib - Attribute to be retrieved.\r\n\t\t * @returns - The retrieved value.\r\n\t\t */\r\n\t\tgetAttrib(attrib: string): string | boolean | null;\r\n\t\t/**\r\n\t\t * Sets the value of the specified attribute.\r\n\t\t *\r\n\t\t * @param attrib - Attribute to be set.\r\n\t\t * @param value - Value to assigned.\r\n\t\t * @returns - IsotopeNode.\r\n\t\t */\r\n\t\tsetAttrib(attrib: string, value?: string | boolean): this;\r\n\t\t/**\r\n\t\t * Sets multiple attributes.\r\n\t\t *\r\n\t\t * @param attribs - Object with key-value pairs of attributes and their values.\r\n\t\t * @returns - IsotopeNode.\r\n\t\t */\r\n\t\tsetAttribs(attribs: Indexable): this;\r\n\t}\r\n\tinterface IsotopeNodeConfig<S extends Indexable, C extends Indexable> {\r\n\t\tattribs?: Indexable | ConfigFunction<S, C, Indexable>;\r\n\t}\r\n}\r\n\r\nif (!IsotopeNode.prototype.setAttribs) {\r\n\tIsotopeNode.prototype.onCreate.push((node, config) => {\r\n\t\tif (config.attribs) {\r\n\t\t\tif (typeof config.attribs === \"function\") {\r\n\t\t\t\tnode.attribs = config.attribs as ConfigFunction<\r\n\t\t\t\t\tany,\r\n\t\t\t\t\tany,\r\n\t\t\t\t\tIndexable<string | boolean>\r\n\t\t\t\t>;\r\n\t\t\t} else {\r\n\t\t\t\tnode.setAttribs(config.attribs);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\tIsotopeNode.prototype.onProcess.push((node) => {\r\n\t\tif (node.attribs) {\r\n\t\t\tnode.setAttribs(node.attribs(node));\r\n\t\t}\r\n\t});\r\n\tObject.assign(IsotopeNode.prototype, {\r\n\t\t/** @private */\r\n\t\tgetAttrib(this: IsotopeNode, attrib: string): string | boolean | null {\r\n\t\t\tconst value = this.element.getAttribute(attrib);\r\n\r\n\t\t\treturn value === \"\" ? true : value;\r\n\t\t},\r\n\t\t/** @private */\r\n\t\tsetAttrib(this: IsotopeNode, attrib: string, value?: string | boolean): IsotopeNode {\r\n\t\t\tif (value) {\r\n\t\t\t\tthis.element.setAttribute(attrib, value === true ? \"\" : value);\r\n\t\t\t} else {\r\n\t\t\t\tthis.element.removeAttribute(attrib);\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\r\n\t\t/** @private */\r\n\t\tsetAttribs(this: IsotopeNode, attribs: Indexable): IsotopeNode {\r\n\t\t\tObject.entries(attribs).forEach(([attrib, value]) => {\r\n\t\t\t\tthis.setAttrib(attrib, value);\r\n\t\t\t});\r\n\r\n\t\t\treturn this;\r\n\t\t}\r\n\t});\r\n}\r\n","import { ConfigFunction, Indexable } from \"../declarations\";\r\nimport { IsotopeNode } from \"../node\";\r\n\r\ndeclare module \"../node\" {\r\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\r\n\t\tclasses?: ConfigFunction<S, C, string[] | Indexable<boolean>>;\r\n\t\t/**\r\n\t\t * Applies the specified CSS class name to the Node's element.\r\n\t\t *\r\n\t\t * @param className - CSS class name to be applied.\r\n\t\t * @returns - IsotopeNode.\r\n\t\t */\r\n\t\taddClass(className: string): this;\r\n\t\t/**\r\n\t\t * Checks if the Node's element contains the specified CSS class name.\r\n\t\t *\r\n\t\t * @param className - CSS class name to be checked.\r\n\t\t * @returns - If the Node's element contains the specified CSS class name.\r\n\t\t */\r\n\t\thasClass(className: string): boolean;\r\n\t\t/**\r\n\t\t * Removes the specified CSS class name from the Node's element.\r\n\t\t *\r\n\t\t * @param className - CSS class name to be removed.\r\n\t\t * @returns - IsotopeNode.\r\n\t\t */\r\n\t\tremoveClass(className: string): this;\r\n\t\t/**\r\n\t\t * Sets multiple CSS class names.\r\n\t\t *\r\n\t\t * @param classes - Object or array with CSS class name to be set.\r\n\t\t * @returns - IsotopeNode.\r\n\t\t */\r\n\t\tsetClasses(classes: string[] | Indexable<boolean>): this;\r\n\t}\r\n\tinterface IsotopeNodeConfig<S extends Indexable, C extends Indexable> {\r\n\t\tclasses?:\r\n\t\t\t| string[]\r\n\t\t\t| Indexable<boolean>\r\n\t\t\t| ConfigFunction<S, C, Indexable<boolean> | string[]>;\r\n\t}\r\n}\r\n\r\nif (!IsotopeNode.prototype.setClasses) {\r\n\tIsotopeNode.prototype.onCreate.push((node, config) => {\r\n\t\tif (config.classes) {\r\n\t\t\tif (typeof config.classes === \"function\") {\r\n\t\t\t\tnode.classes = config.classes;\r\n\t\t\t} else {\r\n\t\t\t\tnode.setClasses(config.classes);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\tIsotopeNode.prototype.onProcess.push((node) => {\r\n\t\tif (node.classes) {\r\n\t\t\tnode.setClasses(node.classes(node));\r\n\t\t}\r\n\t});\r\n\tObject.assign(IsotopeNode.prototype, {\r\n\t\t/** @private */\r\n\t\taddClass(this: IsotopeNode, className: string): IsotopeNode {\r\n\t\t\tthis.element.classList.add(className);\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t/** @private */\r\n\t\thasClass(this: IsotopeNode, className: string): boolean {\r\n\t\t\treturn this.element.classList.contains(className);\r\n\t\t},\r\n\t\t/** @private */\r\n\t\tremoveClass(this: IsotopeNode, className: string): IsotopeNode {\r\n\t\t\tthis.element.classList.remove(className);\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t/** @private */\r\n\t\tsetClasses(this: IsotopeNode, classes: string[] | Indexable<boolean>): IsotopeNode {\r\n\t\t\tif (Array.isArray(classes)) {\r\n\t\t\t\tclasses.forEach((className) => this.addClass(className));\r\n\t\t\t} else {\r\n\t\t\t\tObject.entries(classes).forEach(([className, value]) => {\r\n\t\t\t\t\tif (value) {\r\n\t\t\t\t\t\tthis.addClass(className);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tthis.removeClass(className);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\t\t}\r\n\t});\r\n}\r\n","import { ConfigFunction, Indexable, StyleProperties } from \"../declarations\";\r\nimport { IsotopeNode } from \"../node\";\r\n\r\ndeclare module \"../node\" {\r\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\r\n\t\tstyles?: ConfigFunction<S, C, StyleProperties>;\r\n\t\t/**\r\n\t\t * Retrieves the value of the specified style property.\r\n\t\t *\r\n\t\t * @param property - Property to be retrieved.\r\n\t\t * @returns - The retrieved value.\r\n\t\t */\r\n\t\tgetStyle<P extends keyof StyleProperties>(\r\n\t\t\tproperty: P\r\n\t\t): StyleProperties[P] | undefined;\r\n\t\t/**\r\n\t\t * Sets the specified style property.\r\n\t\t *\r\n\t\t * @param property - Property to be set.\r\n\t\t * @param value - Value to be assigned.\r\n\t\t * @returns - IsotopeNode.\r\n\t\t */\r\n\t\tsetStyle<P extends keyof StyleProperties>(\r\n\t\t\tproperty: P,\r\n\t\t\tvalue: StyleProperties[P]\r\n\t\t): this;\r\n\t\t/**\r\n\t\t * Sets multiple style properties.\r\n\t\t *\r\n\t\t * @param styles - Object with style properties to be set.\r\n\t\t * @returns - IsotopeNode.\r\n\t\t */\r\n\t\tsetStyles(this: IsotopeNode, styles: StyleProperties): this;\r\n\t}\r\n\tinterface IsotopeNodeConfig<S extends Indexable, C extends Indexable> {\r\n\t\tstyles?: StyleProperties | ConfigFunction<S, C, StyleProperties>;\r\n\t}\r\n}\r\n\r\nif (!IsotopeNode.prototype.setStyles) {\r\n\tIsotopeNode.prototype.onCreate.push((node, config) => {\r\n\t\tif (config.styles) {\r\n\t\t\tif (typeof config.styles === \"function\") {\r\n\t\t\t\tnode.styles = config.styles;\r\n\t\t\t} else {\r\n\t\t\t\tnode.setStyles(config.styles);\r\n\t\t\t}\r\n\t\t}\r\n\t});\r\n\tIsotopeNode.prototype.onProcess.push((node) => {\r\n\t\tif (node.styles) {\r\n\t\t\tnode.setStyles(node.styles(node));\r\n\t\t}\r\n\t});\r\n\tObject.assign(IsotopeNode.prototype, {\r\n\t\t/** @private */\r\n\t\tgetStyle<P extends keyof StyleProperties>(\r\n\t\t\tthis: IsotopeNode,\r\n\t\t\tproperty: P\r\n\t\t): StyleProperties[P] | undefined {\r\n\t\t\tconst { style } = this.element;\r\n\r\n\t\t\treturn style ? style[property] : style;\r\n\t\t},\r\n\t\t/** @private */\r\n\t\tsetStyle<P extends keyof StyleProperties>(\r\n\t\t\tthis: IsotopeNode,\r\n\t\t\tproperty: P,\r\n\t\t\tvalue: StyleProperties[P]\r\n\t\t): IsotopeNode {\r\n\t\t\tconst { style } = this.element;\r\n\r\n\t\t\tif (style) {\r\n\t\t\t\tstyle[property] = `${value}${typeof value === \"number\" ? \"px\" : \"\"}` as any;\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\t\t},\r\n\t\t/** @private */\r\n\t\tsetStyles(this: IsotopeNode, styles: StyleProperties): IsotopeNode {\r\n\t\t\tObject.entries(styles).forEach(\r\n\t\t\t\t([property, value]: [keyof StyleProperties, string | number]) => {\r\n\t\t\t\t\tthis.setStyle(property, value);\r\n\t\t\t\t}\r\n\t\t\t);\r\n\r\n\t\t\treturn this;\r\n\t\t}\r\n\t});\r\n}\r\n","interface Change {\r\n\tid: SimpleItem;\r\n\titem?: Item;\r\n\tposition?: number;\r\n\ttype: \"add\" | \"remove\" | \"move\";\r\n}\r\n\r\ninterface DiffingData {\r\n\tchanges: Change[];\r\n\tindex: number;\r\n\tsource: SimpleItem[];\r\n\tsourceInput: Item[];\r\n\ttarget: SimpleItem[];\r\n\ttargetInput: Item[];\r\n}\r\n\r\ninterface MoveData {\r\n\tleft: SimpleItem | null;\r\n\tright: SimpleItem | null;\r\n}\r\n\r\ntype SimpleItem = string | number;\r\n\r\ntype Item = string | number | { id: string | number };\r\n\r\n/**\r\n * Creates the Diffing loop data object.\r\n *\r\n * @param sourceInput - Original, source Item array.\r\n * @param targetInput - Target Item array.\r\n * @returns - Diffing loop data object.\r\n */\r\nconst createData = (sourceInput: Item[], targetInput: Item[]): DiffingData => ({\r\n\tchanges: [],\r\n\tindex: 0,\r\n\tsource: sourceInput.map((item) => `${typeof item === \"object\" ? item.id : item}`),\r\n\tsourceInput,\r\n\ttarget: targetInput.map((item) => `${typeof item === \"object\" ? item.id : item}`),\r\n\ttargetInput\r\n});\r\n/**\r\n * Checks if the diffing loop should be run.\r\n *\r\n * @param data - Diffing loop data.\r\n * @returns - If the diffing loop should be run.\r\n */\r\nconst shouldLoop = ({ index, source, target }: DiffingData): boolean => {\r\n\treturn (\r\n\t\tsource.length > 0 &&\r\n\t\ttarget.length > 0 &&\r\n\t\t(index <= source.length || index <= target.length)\r\n\t);\r\n};\r\n/**\r\n * Trims the diffed arrays from both sides if edge items are equal.\r\n *\r\n * @param data - Diffing loop data.\r\n * @returns - If arrays were trimmed.\r\n */\r\nconst trim = ({ source, target }: DiffingData): boolean => {\r\n\tconst [sourceStart] = source;\r\n\tconst sourceEnd = source[source.length - 1];\r\n\tconst [targetStart] = target;\r\n\tconst targetEnd = target[target.length - 1];\r\n\r\n\tlet trimmed = false;\r\n\r\n\tif (sourceStart === targetStart) {\r\n\t\tsource.shift();\r\n\t\ttarget.shift();\r\n\t\ttrimmed = true;\r\n\t}\r\n\r\n\tif (sourceEnd === targetEnd) {\r\n\t\tsource.pop();\r\n\t\ttarget.pop();\r\n\t\ttrimmed = true;\r\n\t}\r\n\r\n\treturn trimmed;\r\n};\r\n/**\r\n * Detect whether the items should be moved to the opposite site of the array.\r\n *\r\n * @param data - Diffing loop data.\r\n * @returns - Which item should be moved to left and which to right.\r\n */\r\nconst prepareMove = ({ index, source, target }: DiffingData): MoveData => {\r\n\tconst sourceStart = source[index];\r\n\tconst sourceEnd = source[source.length - 1 - index];\r\n\tconst [targetStart] = target;\r\n\tconst targetEnd = target[target.length - 1];\r\n\tconst moveLeft = sourceEnd === targetStart;\r\n\tconst moveRight = sourceStart === targetEnd;\r\n\tconst itemToLeft = moveLeft ? source.splice(source.length - 1 - index, 1)[0] : null;\r\n\tconst itemToRight = moveRight ? source.splice(index, 1)[0] : null;\r\n\r\n\treturn {\r\n\t\tleft: itemToLeft,\r\n\t\tright: itemToRight\r\n\t};\r\n};\r\n/**\r\n * Move the specified items to the opposite site of the array.\r\n *\r\n * @param data - Diffing loop data.\r\n * @param itemToLeft - Item to be moved to the left end.\r\n * @param itemToRight - Item to be moved to the right end.\r\n */\r\nconst move = (\r\n\t{ changes, source }: DiffingData,\r\n\titemToLeft: SimpleItem | null,\r\n\titemToRight: SimpleItem | null\r\n): void => {\r\n\tif (itemToRight !== null) {\r\n\t\tsource.push(itemToRight);\r\n\t\tchanges.push({\r\n\t\t\tid: itemToRight,\r\n\t\t\ttype: \"move\"\r\n\t\t});\r\n\t}\r\n\r\n\tif (itemToLeft !== null) {\r\n\t\tsource.splice(0, 0, itemToLeft);\r\n\t\tchanges.push({\r\n\t\t\tid: itemToLeft,\r\n\t\t\ttype: \"move\"\r\n\t\t});\r\n\t}\r\n};\r\n/**\r\n * Adds the new items from diffed arrays.\r\n *\r\n * @param data - Diffing loop data.\r\n */\r\nconst add = ({ changes, target }: DiffingData): void => {\r\n\ttarget.splice(0).forEach((id) => {\r\n\t\tchanges.push({\r\n\t\t\tid,\r\n\t\t\ttype: \"add\"\r\n\t\t});\r\n\t});\r\n};\r\n/**\r\n * Removes the previous items from diffed arrays.\r\n *\r\n * @param data - Diffing loop data.\r\n */\r\nconst remove = ({ changes, source }: DiffingData): void => {\r\n\tsource.splice(0).forEach((id) => {\r\n\t\tchanges.push({\r\n\t\t\tid,\r\n\t\t\ttype: \"remove\"\r\n\t\t});\r\n\t});\r\n};\r\n/**\r\n * Fills the remaining data required by specific changes.\r\n *\r\n * @param data - Diffing loop data.\r\n */\r\nconst fill = ({ changes, targetInput }: DiffingData): void => {\r\n\tchanges.forEach((change) => {\r\n\t\tconst { id, type } = change;\r\n\r\n\t\tif (type === \"add\" || type === \"move\") {\r\n\t\t\tconst index = targetInput.findIndex((item) => {\r\n\t\t\t\treturn typeof item === \"object\" ? item.id === id : item === id;\r\n\t\t\t});\r\n\r\n\t\t\tif (type === \"add\") {\r\n\t\t\t\tchange.item = targetInput[index];\r\n\t\t\t}\r\n\r\n\t\t\tchange.position = index;\r\n\t\t}\r\n\t});\r\n};\r\n/**\r\n * Detects changes made between 2 Item arrays.\r\n *\r\n * @param sourceInput - Original, source Item array.\r\n * @param targetInput - Target Item array.\r\n * @returns - Changes that differ the second array from the first one.\r\n */\r\nconst detectChanges = (sourceInput: Item[], targetInput: Item[]): Change[] => {\r\n\tconst data = createData(sourceInput, targetInput);\r\n\r\n\twhile (shouldLoop(data)) {\r\n\t\tif (trim(data)) {\r\n\t\t\tdata.index = 0;\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tconst { left, right } = prepareMove(data);\r\n\r\n\t\tif (left !== null || right !== null) {\r\n\t\t\tmove(data, left, right);\r\n\t\t\tdata.index = 0;\r\n\t\t} else {\r\n\t\t\tdata.index += 1;\r\n\t\t}\r\n\t}\r\n\r\n\tadd(data);\r\n\tremove(data);\r\n\tfill(data);\r\n\r\n\treturn data.changes;\r\n};\r\n\r\nexport { detectChanges };\r\n","import { Indexable } from \"../declarations\";\r\nimport { IsotopeNode } from \"../node\";\r\nimport { detectChanges } from \"../utils\";\r\n\r\ninterface MapData<\r\n\tS extends Indexable,\r\n\tC extends Indexable,\r\n\tI extends MappableItem = MappableItem\r\n> {\r\n\titems: Exclude<Mappable<S, C, I>, any[]>;\r\n\tcreateItem(item: any, node: IsotopeNode<S, C>, index: number): IsotopeNode | void;\r\n}\r\n\r\ntype MappableItem = string | number | { id: string | number };\r\n\r\ntype Mappable<\r\n\tS extends Indexable,\r\n\tC extends Indexable,\r\n\tI extends MappableItem = MappableItem\r\n> = I[] | keyof S | ((node: IsotopeNode<S, C>) => I[]);\r\n\r\ndeclare module \"../node\" {\r\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\r\n\t\tmapData?: MapData<S, C> | null;\r\n\t\t/**\r\n\t\t * Maps the provided data to a rendered Nodes list.\r\n\t\t *\r\n\t\t * @param items - Items to be mapped.\r\n\t\t * @param createItem - Rendering function to be used to render mapped items.\r\n\t\t * @returns - The Node.\r\n\t\t */\r\n\t\tmap<I extends MappableItem>(\r\n\t\t\titems: Mappable<S, C, I>,\r\n\t\t\tcreateItem: (item: I, node: this, index: number) => IsotopeNode | void\r\n\t\t): this;\r\n\t}\r\n}\r\n\r\nif (!IsotopeNode.prototype.map) {\r\n\t/**\r\n\t * Handles Nodes map update.\r\n\t *\r\n\t * @param node - The parent Node.\r\n\t * @param items - New items to be mapped.\r\n\t */\r\n\tconst handleMapUpdate = (node: IsotopeNode, items: MappableItem[]): void => {\r\n\t\tconst data = node.mapData!;\r\n\t\tconst changes = detectChanges(\r\n\t\t\t(node.linked as Array<{ id: string | number }>) || [],\r\n\t\t\titems\r\n\t\t);\r\n\r\n\t\tchanges.forEach(({ id, item, position = 0, type }, index) => {\r\n\t\t\tif (type === \"add\") {\r\n\t\t\t\tconst child = data.createItem(item, node, index);\r\n\r\n\t\t\t\tif (child) {\r\n\t\t\t\t\tchild.id = `${id}`;\r\n\t\t\t\t\tnode.link(child, position);\r\n\t\t\t\t\tchild.move(position);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tconst child = node.linked!.find((linked) => linked.id === id);\r\n\r\n\t\t\t\tif (child) {\r\n\t\t\t\t\tif (type === \"remove\") {\r\n\t\t\t\t\t\tchild.remove();\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\tchild.move(position);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\t/**\r\n\t * Handles the Nodes map creation.\r\n\t *\r\n\t * @param node - The parent Node.\r\n\t * @param items - Items to be mapped.\r\n\t */\r\n\tconst handleMapCreation = (node: IsotopeNode, items: MappableItem[]): void => {\r\n\t\tconst data = node.mapData!;\r\n\r\n\t\titems.forEach((item, index) => {\r\n\t\t\tconst child = data.createItem(item, node, index);\r\n\r\n\t\t\tif (child) {\r\n\t\t\t\tchild.id = `${typeof item === \"object\" ? item.id : item}`;\r\n\t\t\t\tnode.link(child);\r\n\t\t\t}\r\n\t\t});\r\n\t};\r\n\t/**\r\n\t * Processes the provided Node's map child tree.\r\n\t *\r\n\t * @param node - Node to be processed.\r\n\t */\r\n\tconst processMap = (node: IsotopeNode): void => {\r\n\t\tif (node.mapData) {\r\n\t\t\tconst data = node.mapData;\r\n\t\t\tconst items: MappableItem[] =\r\n\t\t\t\ttypeof data.items === \"function\" ? data.items(node) : node.getState(data.items);\r\n\r\n\t\t\tif (node.linked) {\r\n\t\t\t\thandleMapUpdate(node, items);\r\n\t\t\t} else {\r\n\t\t\t\thandleMapCreation(node, items);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tIsotopeNode.prototype.onClean.push((node) => {\r\n\t\tif (node.mapData) {\r\n\t\t\tnode.mapData = null;\r\n\t\t}\r\n\t});\r\n\tIsotopeNode.prototype.onProcess.push((node) => {\r\n\t\tif (node.mapData) {\r\n\t\t\tprocessMap(node);\r\n\t\t}\r\n\t});\r\n\tObject.assign(IsotopeNode.prototype, {\r\n\t\t/** @private */\r\n\t\tmap(\r\n\t\t\tthis: IsotopeNode,\r\n\t\t\titems: Mappable<any, any>,\r\n\t\t\tcreateItem: (item: any, node: IsotopeNode, index: number) => IsotopeNode | void\r\n\t\t): IsotopeNode {\r\n\t\t\tthis.clean();\r\n\r\n\t\t\tif (Array.isArray(items)) {\r\n\t\t\t\titems.forEach((item, index) => {\r\n\t\t\t\t\tcreateItem(item, this, index);\r\n\t\t\t\t});\r\n\t\t\t} else {\r\n\t\t\t\tthis.mapData = {\r\n\t\t\t\t\tcreateItem,\r\n\t\t\t\t\titems\r\n\t\t\t\t};\r\n\t\t\t\tprocessMap(this);\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\t\t}\r\n\t});\r\n}\r\n\r\nnew IsotopeNode(\"tag\").map([1], () => {});\r\n","import { Indexable } from \"../declarations\";\r\nimport { IsotopeNode } from \"../node\";\r\n\r\ntype TextData<S extends Indexable, C extends Indexable> = (\r\n\tnode: IsotopeNode<S, C>\r\n) => string;\r\n\r\ndeclare module \"../node\" {\r\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\r\n\t\ttextData?: TextData<S, C> | null;\r\n\t\t/**\r\n\t\t * Sets the Node's element text.\r\n\t\t *\r\n\t\t * @param text - Text to be set.\r\n\t\t * @returns - The Node.\r\n\t\t */\r\n\t\ttext(text: TextData<S, C> | string): this;\r\n\t}\r\n}\r\n\r\nif (!IsotopeNode.prototype.text) {\r\n\t/**\r\n\t * Processes the provided Node's text child tree.\r\n\t *\r\n\t * @param node - Node to be processed.\r\n\t */\r\n\tconst processText = (node: IsotopeNode): void => {\r\n\t\tif (node.textData) {\r\n\t\t\tconst data = node.textData(node);\r\n\r\n\t\t\tif (data !== node.element.textContent) {\r\n\t\t\t\tnode.element.textContent = data;\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tIsotopeNode.prototype.onClean.push((node) => {\r\n\t\tif (node.textData) {\r\n\t\t\tnode.textData = null;\r\n\t\t}\r\n\t});\r\n\tIsotopeNode.prototype.onProcess.push((node) => {\r\n\t\tif (node.textData) {\r\n\t\t\tprocessText(node);\r\n\t\t}\r\n\t});\r\n\tObject.assign(IsotopeNode.prototype, {\r\n\t\t/** @private */\r\n\t\ttext(this: IsotopeNode, text: TextData<any, any> | string): IsotopeNode {\r\n\t\t\tthis.clean();\r\n\r\n\t\t\tif (typeof text === \"function\") {\r\n\t\t\t\tthis.textData = text;\r\n\t\t\t\tprocessText(this);\r\n\t\t\t} else {\r\n\t\t\t\tthis.element.textContent = text;\r\n\t\t\t}\r\n\r\n\t\t\treturn this;\r\n\t\t}\r\n\t});\r\n}\r\n","import { IsotopeNode, IsotopeNodeConfig } from \"../../node\";\r\nimport { Indexable } from \"../../declarations\";\r\n\r\ntype Child = <S extends Indexable = any, C extends Indexable = any>(\r\n\tconfig?: IsotopeNodeConfig<S, C> | string\r\n) => IsotopeNode<S, C>;\r\n\r\n/**\r\n * Registers new Node child function.\r\n *\r\n * @param name - Name for the child.\r\n */\r\nconst registerChild = (name: string): void => {\r\n\t/** @private */\r\n\tif (!IsotopeNode.prototype[name as keyof typeof IsotopeNode.prototype]) {\r\n\t\tIsotopeNode.prototype[name as keyof typeof IsotopeNode.prototype] = function(\r\n\t\t\tthis: IsotopeNode,\r\n\t\t\tconfig?: IsotopeNodeConfig<any, any> | string\r\n\t\t) {\r\n\t\t\treturn this.child(name, config);\r\n\t\t};\r\n\t}\r\n};\r\n\r\nexport { Child, registerChild };\r\n","import { Child, registerChild } from \"./register\";\r\n\r\ndeclare module \"../../node\" {\r\n\tinterface IsotopeNode {\r\n\t\tblockquote: Child;\r\n\t\tdd: Child;\r\n\t\tdiv: Child;\r\n\t\tdl: Child;\r\n\t\tdt: Child;\r\n\t\tfigcaption: Child;\r\n\t\tfigure: Child;\r\n\t\thr: Child;\r\n\t\tli: Child;\r\n\t\tmain: Child;\r\n\t\tol: Child;\r\n\t\tp: Child;\r\n\t\tpre: Child;\r\n\t\tul: Child;\r\n\t}\r\n}\r\n\r\nconst nodes = [\r\n\t\"blockquote\",\r\n\t\"dd\",\r\n\t\"div\",\r\n\t\"dl\",\r\n\t\"dt\",\r\n\t\"figcaption\",\r\n\t\"figure\",\r\n\t\"hr\",\r\n\t\"li\",\r\n\t\"main\",\r\n\t\"ol\",\r\n\t\"p\",\r\n\t\"pre\",\r\n\t\"ul\"\r\n];\r\n\r\nnodes.forEach((name) => {\r\n\tregisterChild(name);\r\n});\r\n","import { Child, registerChild } from \"./register\";\r\n\r\ndeclare module \"../../node\" {\r\n\tinterface IsotopeNode {\r\n\t\tembed: Child;\r\n\t\tiframe: Child;\r\n\t\tobject: Child;\r\n\t\tparam: Child;\r\n\t\tpicture: Child;\r\n\t\tsource: Child;\r\n\t}\r\n}\r\n\r\nconst nodes = [\"embed\", \"iframe\", \"object\", \"param\", \"picture\", \"source\"];\r\n\r\nnodes.forEach((name) => {\r\n\tregisterChild(name);\r\n});\r\n","import { Child, registerChild } from \"./register\";\r\n\r\ndeclare module \"../../node\" {\r\n\tinterface IsotopeNode {\r\n\t\tbutton: Child;\r\n\t\tdatalist: Child;\r\n\t\tfieldset: Child;\r\n\t\tform: Child;\r\n\t\tinput: Child;\r\n\t\tlabel: Child;\r\n\t\tlegend: Child;\r\n\t\tmeter: Child;\r\n\t\toptgroup: Child;\r\n\t\toption: Child;\r\n\t\toutput: Child;\r\n\t\tprogress: Child;\r\n\t\tselect: Child;\r\n\t\ttextarea: Child;\r\n\t}\r\n}\r\n\r\nconst nodes = [\r\n\t\"button\",\r\n\t\"datalist\",\r\n\t\"fieldset\",\r\n\t\"form\",\r\n\t\"input\",\r\n\t\"label\",\r\n\t\"legend\",\r\n\t\"meter\",\r\n\t\"optgroup\",\r\n\t\"option\",\r\n\t\"output\",\r\n\t\"progress\",\r\n\t\"select\",\r\n\t\"textarea\"\r\n];\r\n\r\nnodes.forEach((name) => {\r\n\tregisterChild(name);\r\n});\r\n","import { Child, registerChild } from \"./register\";\r\n\r\ndeclare module \"../../node\" {\r\n\tinterface IsotopeNode {\r\n\t\tdetails: Child;\r\n\t\tdialog: Child;\r\n\t\tmenu: Child;\r\n\t\tsummary: Child;\r\n\t\tcanvas: Child;\r\n\t\tscript: Child;\r\n\t\tnoscript: Child;\r\n\t\tslot: Child;\r\n\t\ttemplate: Child;\r\n\t}\r\n}\r\n\r\nconst nodes = [\r\n\t\"details\",\r\n\t\"dialog\",\r\n\t\"menu\",\r\n\t\"summary\",\r\n\t\"canvas\",\r\n\t\"script\",\r\n\t\"noscript\",\r\n\t\"slot\",\r\n\t\"template\"\r\n];\r\n\r\nnodes.forEach((name) => {\r\n\tregisterChild(name);\r\n});\r\n","import { Child, registerChild } from \"./register\";\r\n\r\ndeclare module \"../../node\" {\r\n\tinterface IsotopeNode {\r\n\t\tarea: Child;\r\n\t\taudio: Child;\r\n\t\timg: Child;\r\n\t\ttrack: Child;\r\n\t\tvideo: Child;\r\n\t}\r\n}\r\n\r\nconst nodes = [\"area\", \"audio\", \"img\", \"track\", \"video\"];\r\n\r\nnodes.forEach((name) => {\r\n\tregisterChild(name);\r\n});\r\n","import { Child, registerChild } from \"./register\";\r\n\r\ndeclare module \"../../node\" {\r\n\tinterface IsotopeNode {\r\n\t\taddress: Child;\r\n\t\tarticle: Child;\r\n\t\taside: Child;\r\n\t\tfooter: Child;\r\n\t\theader: Child;\r\n\t\th1: Child;\r\n\t\th2: Child;\r\n\t\th3: Child;\r\n\t\th4: Child;\r\n\t\th5: Child;\r\n\t\th6: Child;\r\n\t\thgroup: Child;\r\n\t\tmain: Child;\r\n\t\tnav: Child;\r\n\t\tsection: Child;\r\n\t}\r\n}\r\n\r\nconst nodes = [\r\n\t\"address\",\r\n\t\"article\",\r\n\t\"aside\",\r\n\t\"footer\",\r\n\t\"header\",\r\n\t\"h1\",\r\n\t\"h2\",\r\n\t\"h3\",\r\n\t\"h4\",\r\n\t\"h5\",\r\n\t\"h6\",\r\n\t\"hgroup\",\r\n\t\"main\",\r\n\t\"nav\",\r\n\t\"section\"\r\n];\r\n\r\nnodes.forEach((name) => {\r\n\tregisterChild(name);\r\n});\r\n","import { Child, registerChild } from \"./register\";\r\n\r\ndeclare module \"../../node\" {\r\n\tinterface IsotopeNode {\r\n\t\tcaption: Child;\r\n\t\tcol: Child;\r\n\t\tcolgroup: Child;\r\n\t\ttable: Child;\r\n\t\ttbody: Child;\r\n\t\ttd: Child;\r\n\t\ttfoot: Child;\r\n\t\tth: Child;\r\n\t\tthead: Child;\r\n\t\ttr: Child;\r\n\t}\r\n}\r\n\r\nconst nodes = [\r\n\t\"caption\",\r\n\t\"col\",\r\n\t\"colgroup\",\r\n\t\"table\",\r\n\t\"tbody\",\r\n\t\"td\",\r\n\t\"tfoot\",\r\n\t\"th\",\r\n\t\"thead\",\r\n\t\"tr\"\r\n];\r\n\r\nnodes.forEach((name) => {\r\n\tregisterChild(name);\r\n});\r\n","import { Child, registerChild } from \"./register\";\r\n\r\ndeclare module \"../../node\" {\r\n\tinterface IsotopeNode {\r\n\t\tdel: Child;\r\n\t\tins: Child;\r\n\t\ta: Child;\r\n\t\tabbr: Child;\r\n\t\tb: Child;\r\n\t\tbdi: Child;\r\n\t\tbdo: Child;\r\n\t\tbr: Child;\r\n\t\tcite: Child;\r\n\t\tcode: Child;\r\n\t\tdata: Child;\r\n\t\tdfn: Child;\r\n\t\tem: Child;\r\n\t\ti: Child;\r\n\t\tkbd: Child;\r\n\t\tmark: Child;\r\n\t\tq: Child;\r\n\t\trb: Child;\r\n\t\trp: Child;\r\n\t\trt: Child;\r\n\t\trtc: Child;\r\n\t\truby: Child;\r\n\t\ts: Child;\r\n\t\tsamp: Child;\r\n\t\tsmall: Child;\r\n\t\tspan: Child;\r\n\t\tstrong: Child;\r\n\t\tsub: Child;\r\n\t\tsup: Child;\r\n\t\ttime: Child;\r\n\t\tu: Child;\r\n\t\tvar: Child;\r\n\t\twbr: Child;\r\n\t}\r\n}\r\n\r\nconst nodes = [\r\n\t\"del\",\r\n\t\"ins\",\r\n\t\"a\",\r\n\t\"abbr\",\r\n\t\"b\",\r\n\t\"bdi\",\r\n\t\"bdo\",\r\n\t\"br\",\r\n\t\"cite\",\r\n\t\"code\",\r\n\t\"data\",\r\n\t\"dfn\",\r\n\t\"em\",\r\n\t\"i\",\r\n\t\"kbd\",\r\n\t\"mark\",\r\n\t\"q\",\r\n\t\"rb\",\r\n\t\"rp\",\r\n\t\"rt\",\r\n\t\"rtc\",\r\n\t\"ruby\",\r\n\t\"s\",\r\n\t\"samp\",\r\n\t\"small\",\r\n\t\"span\",\r\n\t\"strong\",\r\n\t\"sub\",\r\n\t\"sup\",\r\n\t\"time\",\r\n\t\"u\",\r\n\t\"var\",\r\n\t\"wbr\"\r\n];\r\n\r\nnodes.forEach((name) => {\r\n\tregisterChild(name);\r\n});\r\n","import { IsotopeNode } from \"../node\";\r\n\r\ninterface IsotopeViewConfig {\r\n\tattach?: boolean;\r\n\tclean?: boolean;\r\n}\r\n\r\n/**\r\n * Creates a DOM View.\r\n *\r\n * @param element - Element to append to.\r\n * @param config - DOM View config.\r\n * @returns - The created top-level Node.\r\n */\r\nconst createDOMView = (element: Element, config?: IsotopeViewConfig): IsotopeNode => {\r\n\tif (IsotopeNode.prototype.customDOM) {\r\n\t\tIsotopeNode.prototype.customDOM = null;\r\n\t}\r\n\r\n\tif (!config || (config && config.clean && !config.attach)) {\r\n\t\telement.textContent = \"\";\r\n\t}\r\n\r\n\treturn new IsotopeNode(element, config);\r\n};\r\n\r\nexport { createDOMView };\r\n","import { CustomEvent } from \"../../declarations\";\r\nimport { IsotopeNode } from \"../../node\";\r\nimport { StringElement } from \"./element\";\r\n\r\n/**\r\n * Creates a String View.\r\n *\r\n * @param tag - Tag for the top-level Node.\r\n * @returns - The created top-level Node.\r\n */\r\nconst createStringView = (tag: string): IsotopeNode => {\r\n\tif (!IsotopeNode.prototype.customDOM) {\r\n\t\tIsotopeNode.prototype.customDOM = {\r\n\t\t\t/** @private */\r\n\t\t\tcreateElement(tag: string): StringElement {\r\n\t\t\t\treturn new StringElement(tag);\r\n\t\t\t},\r\n\t\t\t/** @private */\r\n\t\t\tcreateEvent(type: string): CustomEvent {\r\n\t\t\t\treturn { type };\r\n\t\t\t}\r\n\t\t};\r\n\t}\r\n\r\n\treturn new IsotopeNode(tag);\r\n};\r\n\r\nexport { createStringView };\r\n"],"names":["IsotopeNode","[object Object]","element","config","this","getElement","textContent","attach","childIndex","autoLink","state","context","onCreate","forEach","callback","process","directives","Array","isArray","directive","node","tag","shouldAttach","attachTarget","children","appendChild","Object","assign","link","linked","onClean","event","data","dispatchEvent","customDOM","createEvent","Event","key","position","nodeLinkup","linkup","splice","indexOf","push","upperLinked","referenceNode","insertBefore","handler","options","removeEventListener","addEventListener","parentElement","removeChild","emit","namespace","createElement","document","createElementNS","onProcess","prototype","StringElement","add","tokens","classes","contains","token","includes","remove","tagName","type","listener","events","newChild","slice","handleEvent","qualifiedName","attributes","refChild","index","oldChild","value","$textContent","content","map","child","join","styles","entries","style","property","replace","match","toLowerCase","name","setAttribs","attribs","attrib","getAttribute","setAttribute","removeAttribute","setAttrib","setClasses","className","classList","addClass","removeClass","setStyles","setStyle","if","processConditional","conditionalData","condition","processedCondition","Boolean","getState","previous","onTrue","onFalse","clean","shouldLoop","source","target","length","trim","sourceStart","sourceEnd","targetStart","targetEnd","trimmed","shift","pop","prepareMove","moveRight","left","right","move","changes","itemToLeft","itemToRight","id","handleMapUpdate","items","mapData","sourceInput","targetInput","item","createData","change","findIndex","fill","detectChanges","createItem","find","handleMapCreation","processMap","text","processText","textData","registerChild"],"mappings":"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ACdiE,EAAcjE,KCvBD,CACb,UACA,SACA,OACA,UACA,SACA,SACA,WACA,OACA,YAGKhF,QAASgF,IACdiE,EAAcjE,KCjBD,CAAC,OAAQ,QAAS,MAAO,QAAS,SAE1ChF,QAASgF,IACdiE,EAAcjE,KCOD,CACb,UACA,UACA,QACA,SACA,SACA,KACA,KACA,KACA,KACA,KACA,KACA,SACA,OACA,MACA,WAGKhF,QAASgF,IACdiE,EAAcjE,KCxBD,CACb,UACA,MACA,WACA,QACA,QACA,KACA,QACA,KACA,QACA,MAGKhF,QAASgF,IACdiE,EAAcjE,KCSD,CACb,MACA,MACA,IACA,OACA,IACA,MACA,MACA,KACA,OACA,OACA,OACA,MACA,KACA,IACA,MACA,OACA,IACA,KACA,KACA,KACA,MACA,OACA,IACA,OACA,QACA,OACA,SACA,MACA,MACA,OACA,IACA,MACA,OAGKhF,QAASgF,IACdiE,EAAcjE,qCC/DO,EAAC3F,EAAkBC,KACpCH,EAAY2D,UAAUzB,YACzBlC,EAAY2D,UAAUzB,UAAY,QAG9B/B,GAAWA,GAAUA,EAAOmH,QAAUnH,EAAOI,UACjDL,EAAQI,YAAc,IAGhB,IAAIN,EAAYE,EAASC,wBCbR,CAACkB,IACpBrB,EAAY2D,UAAUzB,YAC1BlC,EAAY2D,UAAUzB,UAAY,CAEjCqB,cAAclC,GACN,IAAIuC,EAAcvC,GAG1Bc,YAAYkC,IACJ,CAAEA,KAAAA,MAKL,IAAIrE,EAAYqB"}