{"version":3,"file":"isotope.min.js","sources":["../src/node.ts","../src/views/string/element.ts","../src/nodes/conditional.ts","../src/configurators/attribs.ts","../src/configurators/classes.ts","../src/configurators/styles.ts","../src/utils.ts","../src/nodes/map.ts","../src/nodes/text.ts","../src/nodes/html/register.ts","../src/nodes/html/content.ts","../src/nodes/html/embed.ts","../src/nodes/html/form.ts","../src/nodes/html/interactive.ts","../src/nodes/html/media.ts","../src/nodes/html/section.ts","../src/nodes/html/table.ts","../src/nodes/html/text.ts","../src/views/dom.ts","../src/views/string/string.ts"],"sourcesContent":["import { CustomDOM, CustomElement, Indexable } from \"./declarations\";\n\ninterface IsotopeNodeConfig<S extends Indexable, C extends Indexable> {\n\tnamespace?: string;\n\tautoLink?: boolean;\n\tattach?: boolean;\n\tcontext?: C;\n\tstate?: S;\n}\n\ninterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\tonCreate: Array<(node: this, config: IsotopeNodeConfig<S, C>) => void>;\n\tonProcess: Array<(node: this) => void>;\n\tonClean: Array<(node: this) => void>;\n\tcustomDOM?: CustomDOM | null;\n}\n\ntype Directive<S extends Indexable, C extends Indexable, R extends void | IsotopeNode> = (\n\tnode: IsotopeNode<S, C>\n) => R;\n\n/**\n * Class representing a Node.\n */\nclass IsotopeNode<S extends Indexable = any, C extends Indexable = any>\n\timplements IsotopeNode<S, C> {\n\tpublic state?: S;\n\n\tpublic context?: C;\n\n\tpublic id?: string;\n\n\tpublic linked?: IsotopeNode[] | null;\n\n\tpublic element: CustomElement;\n\n\tprotected linkup?: IsotopeNode | null;\n\n\tprotected childIndex?: number;\n\n\tprotected autoLink?: boolean;\n\n\t/**\n\t * Creates a new Node.\n\t *\n\t * @param element -  The Node's HTML element or tag.\n\t * @param config - The Node's configuration.\n\t */\n\tpublic constructor(\n\t\telement: string | CustomElement | Element,\n\t\tconfig?: IsotopeNodeConfig<S, C> | string\n\t) {\n\t\tthis.element = this.getElement(element, config);\n\n\t\tif (typeof config === \"string\") {\n\t\t\tthis.element.textContent = config;\n\t\t} else if (config) {\n\t\t\tif (config.attach) {\n\t\t\t\tthis.childIndex = 0;\n\t\t\t}\n\n\t\t\tif (config.autoLink) {\n\t\t\t\tthis.autoLink = config.autoLink;\n\t\t\t}\n\n\t\t\tif (config.state) {\n\t\t\t\tthis.state = config.state;\n\t\t\t}\n\n\t\t\tif (config.context) {\n\t\t\t\tthis.context = config.context;\n\t\t\t}\n\n\t\t\tthis.onCreate.forEach((callback) => {\n\t\t\t\tcallback(this, config);\n\t\t\t});\n\t\t}\n\n\t\tthis.process();\n\t}\n\n\t/**\n\t * Executes the provided directive(s).\n\t *\n\t * @param directives - Directive(s) to be executed.\n\t * @returns - The Node.\n\t */\n\tpublic $<R extends void | IsotopeNode>(\n\t\tdirectives: Directive<S, C, R> | Array<Directive<S, C, void>>\n\t): R extends void ? this : R {\n\t\tif (Array.isArray(directives)) {\n\t\t\tdirectives.forEach((directive) => {\n\t\t\t\tdirective(this);\n\t\t\t});\n\t\t} else {\n\t\t\tconst node = directives(this);\n\n\t\t\tif (node) {\n\t\t\t\treturn node as R extends void ? this : R;\n\t\t\t}\n\t\t}\n\n\t\treturn this as R extends void ? this : R;\n\t}\n\n\t/**\n\t * Adds a child Node to the Node.\n\t *\n\t * @param tag - Child Node's HTML tag.\n\t * @param config - Child Node's configuration.\n\t * @returns - The created child Node.\n\t */\n\tpublic child<S2 extends Indexable = Indexable, C2 extends Indexable = Indexable>(\n\t\ttag: string,\n\t\tconfig?: IsotopeNodeConfig<S2, Partial<C> & C2> | string\n\t): IsotopeNode<S2, Partial<C> & C2> {\n\t\tconst shouldAttach = typeof this.childIndex !== \"undefined\";\n\n\t\tlet element: CustomElement | Element | string = tag;\n\n\t\tif (shouldAttach) {\n\t\t\tconst attachTarget = this.element.children[this.childIndex || 0];\n\n\t\t\tif (attachTarget) {\n\t\t\t\telement = attachTarget;\n\t\t\t\tthis.childIndex = (this.childIndex || 0) + 1;\n\t\t\t}\n\t\t}\n\n\t\tconst node = new IsotopeNode<S2, Partial<C> & C2>(element, config);\n\n\t\tthis.element.appendChild(node.element);\n\n\t\tif (shouldAttach && !node.childIndex) {\n\t\t\tnode.childIndex = 0;\n\t\t}\n\n\t\tif (this.context) {\n\t\t\tif (node.context) {\n\t\t\t\tnode.context = Object.assign(node.context, this.context);\n\t\t\t} else {\n\t\t\t\tnode.context = this.context as C & C2;\n\t\t\t}\n\t\t}\n\n\t\tif (this.autoLink) {\n\t\t\tthis.link(node);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Cleans the Node's child tree.\n\t *\n\t * @returns - IsotopeNode.\n\t */\n\tpublic clean(): this {\n\t\tif (this.linked) {\n\t\t\tthis.linked = null;\n\t\t}\n\n\t\tthis.onClean.forEach((callback) => {\n\t\t\tcallback(this);\n\t\t});\n\t\tthis.element.textContent = \"\";\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Emits the specified event.\n\t *\n\t * @param event - Event to be emitted.\n\t * @param data - Data to be passed to the listening function.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic emit(event: string, data: object = {}): this {\n\t\tthis.element.dispatchEvent(\n\t\t\tObject.assign(\n\t\t\t\tthis.customDOM ? this.customDOM.createEvent(event) : new Event(event),\n\t\t\t\t{ node: this },\n\t\t\t\tdata\n\t\t\t)\n\t\t);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Retrieves the data from the Node's context.\n\t *\n\t * @param key - Data key to be retrieved.\n\t * @returns - The retrieved data.\n\t */\n\tpublic getContext<K extends keyof C>(key: K): C[K] | null {\n\t\treturn this.context ? this.context[key] : null;\n\t}\n\n\t/**\n\t * Retrieves the data from the Node's state.\n\t *\n\t * @param key - Data key to be retrieved.\n\t * @returns - The retrieved data.\n\t */\n\tpublic getState<K extends keyof S>(key: K): S[K] | null {\n\t\treturn this.state ? this.state[key] : null;\n\t}\n\n\t/**\n\t * Links the provided Node.\n\t *\n\t * @param node - Node to be linked.\n\t * @param position - Position to place Node at in the linked array.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic link(node: IsotopeNode, position?: number): this {\n\t\tconst nodeLinkup = node.linkup;\n\n\t\tif (nodeLinkup !== this) {\n\t\t\tif (nodeLinkup && nodeLinkup.linked) {\n\t\t\t\tnodeLinkup.linked.splice(nodeLinkup.linked.indexOf(node), 1);\n\t\t\t}\n\n\t\t\tif (!this.linked) {\n\t\t\t\tthis.linked = [];\n\t\t\t}\n\n\t\t\tif (position) {\n\t\t\t\tthis.linked.splice(position, 0, node);\n\t\t\t} else {\n\t\t\t\tthis.linked.push(node);\n\t\t\t}\n\n\t\t\tnode.linkup = this;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Moves the linked Node to the provided position.\n\t *\n\t * @param position - Position index to move the Node to.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic move(position: number): this {\n\t\tconst { linkup } = this;\n\n\t\tif (linkup && linkup.linked) {\n\t\t\tconst upperLinked = linkup.linked;\n\t\t\tconst [node] = upperLinked.splice(upperLinked.indexOf(this as any), 1);\n\n\t\t\tupperLinked.splice(position, 0, node);\n\n\t\t\tconst referenceNode = upperLinked[position + 1];\n\n\t\t\tlinkup.element.insertBefore(\n\t\t\t\tthis.element,\n\t\t\t\treferenceNode ? referenceNode.element : null\n\t\t\t);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Disables the specified event listener.\n\t *\n\t * @param event - Event to disable the listener for.\n\t * @param handler - Event handler to be disabled.\n\t * @param options - Event listening options.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic off<K extends keyof HTMLElementEventMap>(\n\t\tevent: K | string,\n\t\thandler: (ev: HTMLElementEventMap[K]) => any,\n\t\toptions?: boolean | EventListenerOptions\n\t): this;\n\n\t/** @private */\n\tpublic off(\n\t\tevent: string,\n\t\thandler: EventListenerOrEventListenerObject,\n\t\toptions?: boolean | EventListenerOptions\n\t): this {\n\t\tthis.element.removeEventListener(event, handler, options);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Setups an event listener for the specified event.\n\t *\n\t * @param event - Event to be listened to.\n\t * @param handler - Event handling function.\n\t * @param options - Event listening options.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic on<K extends keyof HTMLElementEventMap>(\n\t\tevent: K | string,\n\t\thandler: (data: HTMLElementEventMap[K]) => void,\n\t\toptions?: boolean | AddEventListenerOptions\n\t): this;\n\n\t/** @private */\n\tpublic on(\n\t\tevent: string,\n\t\thandler: EventListenerOrEventListenerObject,\n\t\toptions?: boolean | AddEventListenerOptions\n\t): this {\n\t\tthis.element.addEventListener(event, handler, options);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes the Node.\n\t *\n\t * @returns - IsotopeNode.\n\t */\n\tpublic remove(): this {\n\t\tconst { linkup } = this;\n\n\t\tif (linkup && linkup.linked) {\n\t\t\tlinkup.linked.splice(linkup.linked.indexOf(this as any), 1);\n\t\t}\n\n\t\tif (this.linked) {\n\t\t\tthis.linked = null;\n\t\t}\n\n\t\tif (this.element.parentElement) {\n\t\t\tthis.element.parentElement.removeChild(this.element);\n\t\t}\n\n\t\tthis.emit(\"node-removed\");\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the Node's state.\n\t *\n\t * @param state - State object to be set.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic setState(state: Partial<S>): this {\n\t\tif (this.state) {\n\t\t\tObject.assign(this.state, state);\n\t\t\tthis.emit(\"state-changed\");\n\t\t\tthis.process();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stringifies Node's element.\n\t *\n\t * @returns - Stringified Node's element.\n\t */\n\tpublic toString(): string {\n\t\treturn `${this.element}`;\n\t}\n\n\t/**\n\t * Retrieves the proper element from Node's configuration.\n\t *\n\t * @param element -  The Node's element or tag.\n\t * @param config - The Node's configuration.\n\t * @returns - Retrieved element.\n\t */\n\tprotected getElement(\n\t\telement: string | CustomElement | Element,\n\t\tconfig?: IsotopeNodeConfig<S, C> | string\n\t): CustomElement {\n\t\tif (typeof element === \"string\") {\n\t\t\tif (typeof config === \"object\" && config.namespace) {\n\t\t\t\tif (this.customDOM) {\n\t\t\t\t\treturn this.customDOM.createElement(element, config.namespace);\n\t\t\t\t}\n\n\t\t\t\treturn (document.createElementNS(\n\t\t\t\t\tconfig.namespace,\n\t\t\t\t\telement\n\t\t\t\t) as any) as CustomElement;\n\t\t\t} else if (this.customDOM) {\n\t\t\t\treturn this.customDOM.createElement(element);\n\t\t\t}\n\n\t\t\treturn (document.createElement(element) as any) as CustomElement;\n\t\t}\n\n\t\treturn element as CustomElement;\n\t}\n\n\t/**\n\t * Processes and renders the Node.\n\t */\n\tprotected process(): void {\n\t\tthis.emit(\"node-updated\");\n\t\tthis.onProcess.forEach((callback) => {\n\t\t\tcallback(this);\n\t\t});\n\n\t\tif (this.linked) {\n\t\t\tthis.linked.forEach((linked) => {\n\t\t\t\tlinked.process();\n\t\t\t});\n\t\t}\n\t}\n}\n\nObject.assign(IsotopeNode.prototype, {\n\tonClean: [],\n\tonCreate: [],\n\tonProcess: []\n});\n\nexport { IsotopeNode, IsotopeNodeConfig };\n","/* eslint-disable @typescript-eslint/no-empty-function */\nimport { CustomElement, Indexable } from \"../../declarations\";\nimport { Properties } from \"csstype\";\n\n/**\n * Class implementing Isotope CustomElement API, allowing for easy server-side stringification.\n */\nclass StringElement implements CustomElement {\n\tpublic children: StringElement[] = [];\n\n\tpublic classList = {\n\t\tadd: (...tokens: string[]): void => {\n\t\t\tthis.classes.push(...tokens);\n\t\t},\n\t\tcontains: (token: string): boolean => {\n\t\t\treturn this.classes.includes(token);\n\t\t},\n\t\tremove: (...tokens: string[]): void => {\n\t\t\ttokens.forEach((token) => {\n\t\t\t\tthis.classes.splice(this.classes.indexOf(token), 1);\n\t\t\t});\n\t\t}\n\t};\n\n\tpublic parentElement: StringElement | null = null;\n\n\tpublic style: Properties<string> = {};\n\n\tpublic tagName: string;\n\n\tprotected attributes: { [name: string]: string | null } = {};\n\n\tprotected classes: string[] = [];\n\n\tprivate $textContent: string | null = \"\";\n\n\tprivate events: Indexable<EventListenerOrEventListenerObject[]> = {};\n\n\t/**\n\t * Creates a new ServerElement instance.\n\t *\n\t * @param tag - Tag to be used for the element.\n\t */\n\tpublic constructor(tag: string) {\n\t\tthis.tagName = tag;\n\t}\n\n\t/** @private */\n\tpublic addEventListener(\n\t\ttype: string,\n\t\tlistener: EventListenerOrEventListenerObject\n\t): void {\n\t\t(this.events[type] || (this.events[type] = [])).push(listener);\n\t}\n\n\t/** @private */\n\tpublic appendChild(newChild: StringElement): StringElement {\n\t\tthis.children.push(newChild);\n\t\tnewChild.parentElement = this;\n\n\t\treturn newChild;\n\t}\n\n\t/** @private */\n\tpublic dispatchEvent(event: CustomEvent): boolean {\n\t\t(this.events[event.type] || []).slice().forEach((handler) => {\n\t\t\tif (typeof handler === \"function\") {\n\t\t\t\thandler(event);\n\t\t\t} else {\n\t\t\t\thandler.handleEvent(event);\n\t\t\t}\n\t\t});\n\n\t\treturn true;\n\t}\n\n\t/** @private */\n\tpublic getAttribute(qualifiedName: string): string | null {\n\t\treturn this.attributes[qualifiedName];\n\t}\n\n\t/** @private */\n\tpublic insertBefore(\n\t\tnewChild: StringElement,\n\t\trefChild: StringElement | null\n\t): StringElement {\n\t\tnewChild.parentElement = this;\n\n\t\tif (refChild) {\n\t\t\tconst index = this.children.indexOf(refChild);\n\n\t\t\tif (index >= 0) {\n\t\t\t\tthis.children.splice(index + 1, 0, newChild);\n\n\t\t\t\treturn newChild;\n\t\t\t}\n\t\t}\n\n\t\tthis.children.push(newChild);\n\n\t\treturn newChild;\n\t}\n\n\t/** @private */\n\tpublic removeAttribute(qualifiedName: string): void {\n\t\tthis.attributes[qualifiedName] = null;\n\t}\n\n\t/** @private */\n\tpublic removeChild(oldChild: StringElement): StringElement {\n\t\toldChild.parentElement = null;\n\t\tthis.children.splice(this.children.indexOf(oldChild), 1);\n\n\t\treturn oldChild;\n\t}\n\n\t/** @private */\n\tpublic removeEventListener(\n\t\ttype: string,\n\t\tlistener: EventListenerOrEventListenerObject\n\t): void {\n\t\tif (this.events[type]) {\n\t\t\tthis.events[type].splice(this.events[type].indexOf(listener) >>> 0, 1);\n\t\t}\n\t}\n\n\t/** @private */\n\tpublic setAttribute(qualifiedName: string, value: string): void {\n\t\tthis.attributes[qualifiedName] = value;\n\t}\n\n\t/** @private */\n\tpublic set textContent(textContent: string | null) {\n\t\tthis.children = [];\n\t\tthis.$textContent = textContent || \"\";\n\t}\n\n\t/** @private */\n\tpublic get textContent(): string | null {\n\t\treturn this.$textContent;\n\t}\n\n\t/**\n\t * Stringifies the ServerElement.\n\t *\n\t * @returns - Stringified ServerElement.\n\t */\n\tpublic toString(): string {\n\t\tconst tag = this.tagName;\n\t\tconst content =\n\t\t\tthis.textContent ||\n\t\t\tthis.children\n\t\t\t\t.map((child) => {\n\t\t\t\t\treturn `${child}`;\n\t\t\t\t})\n\t\t\t\t.join(\"\");\n\t\tconst classes = this.classes.join(\" \");\n\t\tconst styles = Object.entries(this.style)\n\t\t\t.map(([property, value]) => {\n\t\t\t\tconst propertyKebabCase = property.replace(\n\t\t\t\t\t/[A-Z]/g,\n\t\t\t\t\t(match) => `-${match.toLowerCase()}`\n\t\t\t\t);\n\n\t\t\t\treturn `${propertyKebabCase}:${value}`;\n\t\t\t})\n\t\t\t.join(\";\");\n\t\tconst attributes = Object.entries(this.attributes)\n\t\t\t.map(([name, value]) => {\n\t\t\t\treturn `${name}=\"${value}\"`;\n\t\t\t})\n\t\t\t.join(\" \");\n\n\t\treturn `<${tag}${classes ? ` class=\"${classes}\"` : \"\"}${\n\t\t\tstyles ? `style=\"${styles}\"` : \"\"\n\t\t}${attributes}>${content}</${tag}>`;\n\t}\n}\n\nexport { StringElement };\n","import { Indexable } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\n\ninterface ConditionalData<S extends Indexable, C extends Indexable> {\n\tprevious?: boolean;\n\tcondition: keyof S | ((node: IsotopeNode<S, C>) => boolean);\n\tonTrue(node: IsotopeNode<S, C>): IsotopeNode | void;\n\tonFalse?(node: IsotopeNode<S, C>): IsotopeNode | void;\n}\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\tconditionalData?: ConditionalData<S, C> | null;\n\t\t/**\n\t\t * Conditionally renders the provided nodes.\n\t\t *\n\t\t * @param condition - Condition to be checked.\n\t\t * @param onTrue - Rendering function to be executed when condition is truthy.\n\t\t * @param onFalse - Rendering function to be executed when condition is falsy.\n\t\t * @returns - The Node.\n\t\t */\n\t\tif(\n\t\t\tcondition: boolean | keyof S | ((node: this) => boolean),\n\t\t\tonTrue: (node: this) => IsotopeNode | void,\n\t\t\tonFalse?: (node: this) => IsotopeNode | void\n\t\t): this;\n\t}\n}\n\nif (!IsotopeNode.prototype.if) {\n\t/**\n\t * Processes the provided Node's conditional child tree.\n\t *\n\t * @param node - Node to be processed.\n\t */\n\tconst processConditional = (node: IsotopeNode): void => {\n\t\tif (node.conditionalData) {\n\t\t\tconst data = node.conditionalData;\n\t\t\tconst { condition } = data;\n\t\t\tconst processedCondition = Boolean(\n\t\t\t\ttypeof condition === \"function\" ? condition(node) : node.getState(condition)\n\t\t\t);\n\n\t\t\tif (processedCondition !== data.previous) {\n\t\t\t\tnode.element.textContent = \"\";\n\t\t\t\tnode.linked = null;\n\n\t\t\t\tif (processedCondition) {\n\t\t\t\t\tdata.onTrue(node);\n\t\t\t\t} else if (data.onFalse) {\n\t\t\t\t\tdata.onFalse(node);\n\t\t\t\t}\n\n\t\t\t\tdata.previous = processedCondition;\n\t\t\t}\n\t\t}\n\t};\n\n\tIsotopeNode.prototype.onClean.push((node) => {\n\t\tif (node.conditionalData) {\n\t\t\tnode.conditionalData = null;\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.conditionalData) {\n\t\t\tprocessConditional(node);\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\tif(\n\t\t\tthis: IsotopeNode,\n\t\t\tcondition: boolean | string | ((node: IsotopeNode) => boolean),\n\t\t\tonTrue: (node: IsotopeNode) => IsotopeNode | void,\n\t\t\tonFalse?: (node: IsotopeNode) => IsotopeNode | void\n\t\t): IsotopeNode {\n\t\t\tthis.clean();\n\n\t\t\tif (typeof condition === \"boolean\") {\n\t\t\t\tif (condition) {\n\t\t\t\t\tonTrue(this);\n\t\t\t\t} else if (onFalse) {\n\t\t\t\t\tonFalse(this);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.conditionalData = {\n\t\t\t\t\tcondition,\n\t\t\t\t\tonFalse,\n\t\t\t\t\tonTrue\n\t\t\t\t};\n\t\t\t\tprocessConditional(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","import { ConfigFunction, Indexable } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\tattribs?: ConfigFunction<S, C, Indexable<string | boolean>>;\n\t\t/**\n\t\t * Retrieves the value of the specified attribute.\n\t\t *\n\t\t * @param attrib - Attribute to be retrieved.\n\t\t * @returns - The retrieved value.\n\t\t */\n\t\tgetAttrib(attrib: string): string | boolean | null;\n\t\t/**\n\t\t * Sets the value of the specified attribute.\n\t\t *\n\t\t * @param attrib - Attribute to be set.\n\t\t * @param value - Value to assigned.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tsetAttrib(attrib: string, value?: string | boolean): this;\n\t\t/**\n\t\t * Sets multiple attributes.\n\t\t *\n\t\t * @param attribs - Object with key-value pairs of attributes and their values.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tsetAttribs(attribs: Indexable): this;\n\t}\n\tinterface IsotopeNodeConfig<S extends Indexable, C extends Indexable> {\n\t\tattribs?: Indexable | ConfigFunction<S, C, Indexable>;\n\t}\n}\n\nif (!IsotopeNode.prototype.setAttribs) {\n\tIsotopeNode.prototype.onCreate.push((node, config) => {\n\t\tif (config.attribs) {\n\t\t\tif (typeof config.attribs === \"function\") {\n\t\t\t\tnode.attribs = config.attribs as ConfigFunction<\n\t\t\t\t\tany,\n\t\t\t\t\tany,\n\t\t\t\t\tIndexable<string | boolean>\n\t\t\t\t>;\n\t\t\t} else {\n\t\t\t\tnode.setAttribs(config.attribs);\n\t\t\t}\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.attribs) {\n\t\t\tnode.setAttribs(node.attribs(node));\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\tgetAttrib(this: IsotopeNode, attrib: string): string | boolean | null {\n\t\t\tconst value = this.element.getAttribute(attrib);\n\n\t\t\treturn value === \"\" ? true : value;\n\t\t},\n\t\t/** @private */\n\t\tsetAttrib(this: IsotopeNode, attrib: string, value?: string | boolean): IsotopeNode {\n\t\t\tif (value) {\n\t\t\t\tthis.element.setAttribute(attrib, value === true ? \"\" : value);\n\t\t\t} else {\n\t\t\t\tthis.element.removeAttribute(attrib);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t/** @private */\n\t\tsetAttribs(this: IsotopeNode, attribs: Indexable): IsotopeNode {\n\t\t\tObject.entries(attribs).forEach(([attrib, value]) => {\n\t\t\t\tthis.setAttrib(attrib, value);\n\t\t\t});\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","import { ConfigFunction, Indexable } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\tclasses?: ConfigFunction<S, C, string[] | Indexable<boolean>>;\n\t\t/**\n\t\t * Applies the specified CSS class name to the Node's element.\n\t\t *\n\t\t * @param className - CSS class name to be applied.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\taddClass(className: string): this;\n\t\t/**\n\t\t * Checks if the Node's element contains the specified CSS class name.\n\t\t *\n\t\t * @param className - CSS class name to be checked.\n\t\t * @returns - If the Node's element contains the specified CSS class name.\n\t\t */\n\t\thasClass(className: string): boolean;\n\t\t/**\n\t\t * Removes the specified CSS class name from the Node's element.\n\t\t *\n\t\t * @param className - CSS class name to be removed.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tremoveClass(className: string): this;\n\t\t/**\n\t\t * Sets multiple CSS class names.\n\t\t *\n\t\t * @param classes - Object or array with CSS class name to be set.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tsetClasses(classes: string[] | Indexable<boolean>): this;\n\t}\n\tinterface IsotopeNodeConfig<S extends Indexable, C extends Indexable> {\n\t\tclasses?:\n\t\t\t| string[]\n\t\t\t| Indexable<boolean>\n\t\t\t| ConfigFunction<S, C, Indexable<boolean> | string[]>;\n\t}\n}\n\nif (!IsotopeNode.prototype.setClasses) {\n\tIsotopeNode.prototype.onCreate.push((node, config) => {\n\t\tif (config.classes) {\n\t\t\tif (typeof config.classes === \"function\") {\n\t\t\t\tnode.classes = config.classes;\n\t\t\t} else {\n\t\t\t\tnode.setClasses(config.classes);\n\t\t\t}\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.classes) {\n\t\t\tnode.setClasses(node.classes(node));\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\taddClass(this: IsotopeNode, className: string): IsotopeNode {\n\t\t\tthis.element.classList.add(className);\n\n\t\t\treturn this;\n\t\t},\n\t\t/** @private */\n\t\thasClass(this: IsotopeNode, className: string): boolean {\n\t\t\treturn this.element.classList.contains(className);\n\t\t},\n\t\t/** @private */\n\t\tremoveClass(this: IsotopeNode, className: string): IsotopeNode {\n\t\t\tthis.element.classList.remove(className);\n\n\t\t\treturn this;\n\t\t},\n\t\t/** @private */\n\t\tsetClasses(this: IsotopeNode, classes: string[] | Indexable<boolean>): IsotopeNode {\n\t\t\tif (Array.isArray(classes)) {\n\t\t\t\tclasses.forEach((className) => this.addClass(className));\n\t\t\t} else {\n\t\t\t\tObject.entries(classes).forEach(([className, value]) => {\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tthis.addClass(className);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.removeClass(className);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","import { ConfigFunction, Indexable, StyleProperties } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\tstyles?: ConfigFunction<S, C, StyleProperties>;\n\t\t/**\n\t\t * Retrieves the value of the specified style property.\n\t\t *\n\t\t * @param property - Property to be retrieved.\n\t\t * @returns - The retrieved value.\n\t\t */\n\t\tgetStyle<P extends keyof StyleProperties>(\n\t\t\tproperty: P\n\t\t): StyleProperties[P] | undefined;\n\t\t/**\n\t\t * Sets the specified style property.\n\t\t *\n\t\t * @param property - Property to be set.\n\t\t * @param value - Value to be assigned.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tsetStyle<P extends keyof StyleProperties>(\n\t\t\tproperty: P,\n\t\t\tvalue: StyleProperties[P]\n\t\t): this;\n\t\t/**\n\t\t * Sets multiple style properties.\n\t\t *\n\t\t * @param styles - Object with style properties to be set.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tsetStyles(this: IsotopeNode, styles: StyleProperties): this;\n\t}\n\tinterface IsotopeNodeConfig<S extends Indexable, C extends Indexable> {\n\t\tstyles?: StyleProperties | ConfigFunction<S, C, StyleProperties>;\n\t}\n}\n\nif (!IsotopeNode.prototype.setStyles) {\n\tIsotopeNode.prototype.onCreate.push((node, config) => {\n\t\tif (config.styles) {\n\t\t\tif (typeof config.styles === \"function\") {\n\t\t\t\tnode.styles = config.styles;\n\t\t\t} else {\n\t\t\t\tnode.setStyles(config.styles);\n\t\t\t}\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.styles) {\n\t\t\tnode.setStyles(node.styles(node));\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\tgetStyle<P extends keyof StyleProperties>(\n\t\t\tthis: IsotopeNode,\n\t\t\tproperty: P\n\t\t): StyleProperties[P] | undefined {\n\t\t\tconst { style } = this.element;\n\n\t\t\treturn style ? style[property] : style;\n\t\t},\n\t\t/** @private */\n\t\tsetStyle<P extends keyof StyleProperties>(\n\t\t\tthis: IsotopeNode,\n\t\t\tproperty: P,\n\t\t\tvalue: StyleProperties[P]\n\t\t): IsotopeNode {\n\t\t\tconst { style } = this.element;\n\n\t\t\tif (style) {\n\t\t\t\tstyle[property] = `${value}${typeof value === \"number\" ? \"px\" : \"\"}` as any;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\t\t/** @private */\n\t\tsetStyles(this: IsotopeNode, styles: StyleProperties): IsotopeNode {\n\t\t\tObject.entries(styles).forEach(\n\t\t\t\t([property, value]: [keyof StyleProperties, string | number]) => {\n\t\t\t\t\tthis.setStyle(property, value);\n\t\t\t\t}\n\t\t\t);\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","interface Change {\n\tid: SimpleItem;\n\titem?: Item;\n\tposition?: number;\n\ttype: \"add\" | \"remove\" | \"move\";\n}\n\ninterface DiffingData {\n\tchanges: Change[];\n\tindex: number;\n\tsource: SimpleItem[];\n\tsourceInput: Item[];\n\ttarget: SimpleItem[];\n\ttargetInput: Item[];\n}\n\ninterface MoveData {\n\tleft: SimpleItem | null;\n\tright: SimpleItem | null;\n}\n\ntype SimpleItem = string | number;\n\ntype Item = string | number | { id: string | number };\n\n/**\n * Creates the Diffing loop data object.\n *\n * @param sourceInput - Original, source Item array.\n * @param targetInput - Target Item array.\n * @returns - Diffing loop data object.\n */\nconst createData = (sourceInput: Item[], targetInput: Item[]): DiffingData => ({\n\tchanges: [],\n\tindex: 0,\n\tsource: sourceInput.map((item) => `${typeof item === \"object\" ? item.id : item}`),\n\tsourceInput,\n\ttarget: targetInput.map((item) => `${typeof item === \"object\" ? item.id : item}`),\n\ttargetInput\n});\n/**\n * Checks if the diffing loop should be run.\n *\n * @param data - Diffing loop data.\n * @returns - If the diffing loop should be run.\n */\nconst shouldLoop = ({ index, source, target }: DiffingData): boolean => {\n\treturn (\n\t\tsource.length > 0 &&\n\t\ttarget.length > 0 &&\n\t\t(index <= source.length || index <= target.length)\n\t);\n};\n/**\n * Trims the diffed arrays from both sides if edge items are equal.\n *\n * @param data - Diffing loop data.\n * @returns - If arrays were trimmed.\n */\nconst trim = ({ source, target }: DiffingData): boolean => {\n\tconst [sourceStart] = source;\n\tconst sourceEnd = source[source.length - 1];\n\tconst [targetStart] = target;\n\tconst targetEnd = target[target.length - 1];\n\n\tlet trimmed = false;\n\n\tif (sourceStart === targetStart) {\n\t\tsource.shift();\n\t\ttarget.shift();\n\t\ttrimmed = true;\n\t}\n\n\tif (sourceEnd === targetEnd) {\n\t\tsource.pop();\n\t\ttarget.pop();\n\t\ttrimmed = true;\n\t}\n\n\treturn trimmed;\n};\n/**\n * Detect whether the items should be moved to the opposite site of the array.\n *\n * @param data - Diffing loop data.\n * @returns - Which item should be moved to left and which to right.\n */\nconst prepareMove = ({ index, source, target }: DiffingData): MoveData => {\n\tconst sourceStart = source[index];\n\tconst sourceEnd = source[source.length - 1 - index];\n\tconst [targetStart] = target;\n\tconst targetEnd = target[target.length - 1];\n\tconst moveLeft = sourceEnd === targetStart;\n\tconst moveRight = sourceStart === targetEnd;\n\tconst itemToLeft = moveLeft ? source.splice(source.length - 1 - index, 1)[0] : null;\n\tconst itemToRight = moveRight ? source.splice(index, 1)[0] : null;\n\n\treturn {\n\t\tleft: itemToLeft,\n\t\tright: itemToRight\n\t};\n};\n/**\n * Move the specified items to the opposite site of the array.\n *\n * @param data - Diffing loop data.\n * @param itemToLeft - Item to be moved to the left end.\n * @param itemToRight - Item to be moved to the right end.\n */\nconst move = (\n\t{ changes, source }: DiffingData,\n\titemToLeft: SimpleItem | null,\n\titemToRight: SimpleItem | null\n): void => {\n\tif (itemToRight !== null) {\n\t\tsource.push(itemToRight);\n\t\tchanges.push({\n\t\t\tid: itemToRight,\n\t\t\ttype: \"move\"\n\t\t});\n\t}\n\n\tif (itemToLeft !== null) {\n\t\tsource.splice(0, 0, itemToLeft);\n\t\tchanges.push({\n\t\t\tid: itemToLeft,\n\t\t\ttype: \"move\"\n\t\t});\n\t}\n};\n/**\n * Adds the new items from diffed arrays.\n *\n * @param data - Diffing loop data.\n */\nconst add = ({ changes, target }: DiffingData): void => {\n\ttarget.splice(0).forEach((id) => {\n\t\tchanges.push({\n\t\t\tid,\n\t\t\ttype: \"add\"\n\t\t});\n\t});\n};\n/**\n * Removes the previous items from diffed arrays.\n *\n * @param data - Diffing loop data.\n */\nconst remove = ({ changes, source }: DiffingData): void => {\n\tsource.splice(0).forEach((id) => {\n\t\tchanges.push({\n\t\t\tid,\n\t\t\ttype: \"remove\"\n\t\t});\n\t});\n};\n/**\n * Fills the remaining data required by specific changes.\n *\n * @param data - Diffing loop data.\n */\nconst fill = ({ changes, targetInput }: DiffingData): void => {\n\tchanges.forEach((change) => {\n\t\tconst { id, type } = change;\n\n\t\tif (type === \"add\" || type === \"move\") {\n\t\t\tconst index = targetInput.findIndex((item) => {\n\t\t\t\treturn typeof item === \"object\" ? item.id === id : item === id;\n\t\t\t});\n\n\t\t\tif (type === \"add\") {\n\t\t\t\tchange.item = targetInput[index];\n\t\t\t}\n\n\t\t\tchange.position = index;\n\t\t}\n\t});\n};\n/**\n * Detects changes made between 2 Item arrays.\n *\n * @param sourceInput - Original, source Item array.\n * @param targetInput - Target Item array.\n * @returns - Changes that differ the second array from the first one.\n */\nconst detectChanges = (sourceInput: Item[], targetInput: Item[]): Change[] => {\n\tconst data = createData(sourceInput, targetInput);\n\n\twhile (shouldLoop(data)) {\n\t\tif (trim(data)) {\n\t\t\tdata.index = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst { left, right } = prepareMove(data);\n\n\t\tif (left !== null || right !== null) {\n\t\t\tmove(data, left, right);\n\t\t\tdata.index = 0;\n\t\t} else {\n\t\t\tdata.index += 1;\n\t\t}\n\t}\n\n\tadd(data);\n\tremove(data);\n\tfill(data);\n\n\treturn data.changes;\n};\n\nexport { detectChanges };\n","import { Indexable } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\nimport { detectChanges } from \"../utils\";\n\ninterface MapData<\n\tS extends Indexable,\n\tC extends Indexable,\n\tI extends MappableItem = MappableItem\n> {\n\titems: Exclude<Mappable<S, C, I>, any[]>;\n\tcreateItem(item: any, node: IsotopeNode<S, C>, index: number): IsotopeNode | void;\n}\n\ntype MappableItem = string | number | { id: string | number };\n\ntype Mappable<\n\tS extends Indexable,\n\tC extends Indexable,\n\tI extends MappableItem = MappableItem\n> = I[] | keyof S | ((node: IsotopeNode<S, C>) => I[]);\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\tmapData?: MapData<S, C> | null;\n\t\t/**\n\t\t * Maps the provided data to a rendered Nodes list.\n\t\t *\n\t\t * @param items - Items to be mapped.\n\t\t * @param createItem - Rendering function to be used to render mapped items.\n\t\t * @returns - The Node.\n\t\t */\n\t\tmap<I extends MappableItem>(\n\t\t\titems: Mappable<S, C, I>,\n\t\t\tcreateItem: (item: I, node: this, index: number) => IsotopeNode | void\n\t\t): this;\n\t}\n}\n\nif (!IsotopeNode.prototype.map) {\n\t/**\n\t * Handles Nodes map update.\n\t *\n\t * @param node - The parent Node.\n\t * @param items - New items to be mapped.\n\t */\n\tconst handleMapUpdate = (node: IsotopeNode, items: MappableItem[]): void => {\n\t\tconst data = node.mapData!;\n\t\tconst changes = detectChanges(\n\t\t\t(node.linked as Array<{ id: string | number }>) || [],\n\t\t\titems\n\t\t);\n\n\t\tchanges.forEach(({ id, item, position = 0, type }, index) => {\n\t\t\tif (type === \"add\") {\n\t\t\t\tconst child = data.createItem(item, node, index);\n\n\t\t\t\tif (child) {\n\t\t\t\t\tchild.id = `${id}`;\n\t\t\t\t\tnode.link(child, position);\n\t\t\t\t\tchild.move(position);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst child = node.linked!.find((linked) => linked.id === id);\n\n\t\t\t\tif (child) {\n\t\t\t\t\tif (type === \"remove\") {\n\t\t\t\t\t\tchild.remove();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchild.move(position);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Handles the Nodes map creation.\n\t *\n\t * @param node - The parent Node.\n\t * @param items - Items to be mapped.\n\t */\n\tconst handleMapCreation = (node: IsotopeNode, items: MappableItem[]): void => {\n\t\tconst data = node.mapData!;\n\n\t\titems.forEach((item, index) => {\n\t\t\tconst child = data.createItem(item, node, index);\n\n\t\t\tif (child) {\n\t\t\t\tchild.id = `${typeof item === \"object\" ? item.id : item}`;\n\t\t\t\tnode.link(child);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Processes the provided Node's map child tree.\n\t *\n\t * @param node - Node to be processed.\n\t */\n\tconst processMap = (node: IsotopeNode): void => {\n\t\tif (node.mapData) {\n\t\t\tconst data = node.mapData;\n\t\t\tconst items: MappableItem[] =\n\t\t\t\ttypeof data.items === \"function\" ? data.items(node) : node.getState(data.items);\n\n\t\t\tif (node.linked) {\n\t\t\t\thandleMapUpdate(node, items);\n\t\t\t} else {\n\t\t\t\thandleMapCreation(node, items);\n\t\t\t}\n\t\t}\n\t};\n\n\tIsotopeNode.prototype.onClean.push((node) => {\n\t\tif (node.mapData) {\n\t\t\tnode.mapData = null;\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.mapData) {\n\t\t\tprocessMap(node);\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\tmap(\n\t\t\tthis: IsotopeNode,\n\t\t\titems: Mappable<any, any>,\n\t\t\tcreateItem: (item: any, node: IsotopeNode, index: number) => IsotopeNode | void\n\t\t): IsotopeNode {\n\t\t\tthis.clean();\n\n\t\t\tif (Array.isArray(items)) {\n\t\t\t\titems.forEach((item, index) => {\n\t\t\t\t\tcreateItem(item, this, index);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.mapData = {\n\t\t\t\t\tcreateItem,\n\t\t\t\t\titems\n\t\t\t\t};\n\t\t\t\tprocessMap(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","import { Indexable } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\n\ntype TextData<S extends Indexable, C extends Indexable> = (\n\tnode: IsotopeNode<S, C>\n) => string;\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\ttextData?: TextData<S, C> | null;\n\t\t/**\n\t\t * Sets the Node's element text.\n\t\t *\n\t\t * @param text - Text to be set.\n\t\t * @returns - The Node.\n\t\t */\n\t\ttext(text: TextData<S, C> | string): this;\n\t}\n}\n\nif (!IsotopeNode.prototype.text) {\n\t/**\n\t * Processes the provided Node's text child tree.\n\t *\n\t * @param node - Node to be processed.\n\t */\n\tconst processText = (node: IsotopeNode): void => {\n\t\tif (node.textData) {\n\t\t\tconst data = node.textData(node);\n\n\t\t\tif (data !== node.element.textContent) {\n\t\t\t\tnode.element.textContent = data;\n\t\t\t}\n\t\t}\n\t};\n\n\tIsotopeNode.prototype.onClean.push((node) => {\n\t\tif (node.textData) {\n\t\t\tnode.textData = null;\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.textData) {\n\t\t\tprocessText(node);\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\ttext(this: IsotopeNode, text: TextData<any, any> | string): IsotopeNode {\n\t\t\tthis.clean();\n\n\t\t\tif (typeof text === \"function\") {\n\t\t\t\tthis.textData = text;\n\t\t\t\tprocessText(this);\n\t\t\t} else {\n\t\t\t\tthis.element.textContent = text;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","import { IsotopeNode, IsotopeNodeConfig } from \"../../node\";\nimport { Indexable } from \"../../declarations\";\n\ntype Child = <S extends Indexable = any, C extends Indexable = any>(\n\tconfig?: IsotopeNodeConfig<S, C> | string\n) => IsotopeNode<S, C>;\n\n/**\n * Registers new Node child function.\n *\n * @param name - Name for the child.\n */\nconst registerChild = (name: string): void => {\n\t/** @private */\n\tif (!IsotopeNode.prototype[name as keyof typeof IsotopeNode.prototype]) {\n\t\tIsotopeNode.prototype[name as keyof typeof IsotopeNode.prototype] = function(\n\t\t\tthis: IsotopeNode,\n\t\t\tconfig?: IsotopeNodeConfig<any, any> | string\n\t\t) {\n\t\t\treturn this.child(name, config);\n\t\t};\n\t}\n};\n\nexport { Child, registerChild };\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tblockquote: Child;\n\t\tdd: Child;\n\t\tdiv: Child;\n\t\tdl: Child;\n\t\tdt: Child;\n\t\tfigcaption: Child;\n\t\tfigure: Child;\n\t\thr: Child;\n\t\tli: Child;\n\t\tmain: Child;\n\t\tol: Child;\n\t\tp: Child;\n\t\tpre: Child;\n\t\tul: Child;\n\t}\n}\n\nconst nodes = [\n\t\"blockquote\",\n\t\"dd\",\n\t\"div\",\n\t\"dl\",\n\t\"dt\",\n\t\"figcaption\",\n\t\"figure\",\n\t\"hr\",\n\t\"li\",\n\t\"main\",\n\t\"ol\",\n\t\"p\",\n\t\"pre\",\n\t\"ul\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tembed: Child;\n\t\tiframe: Child;\n\t\tobject: Child;\n\t\tparam: Child;\n\t\tpicture: Child;\n\t\tsource: Child;\n\t}\n}\n\nconst nodes = [\"embed\", \"iframe\", \"object\", \"param\", \"picture\", \"source\"];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tbutton: Child;\n\t\tdatalist: Child;\n\t\tfieldset: Child;\n\t\tform: Child;\n\t\tinput: Child;\n\t\tlabel: Child;\n\t\tlegend: Child;\n\t\tmeter: Child;\n\t\toptgroup: Child;\n\t\toption: Child;\n\t\toutput: Child;\n\t\tprogress: Child;\n\t\tselect: Child;\n\t\ttextarea: Child;\n\t}\n}\n\nconst nodes = [\n\t\"button\",\n\t\"datalist\",\n\t\"fieldset\",\n\t\"form\",\n\t\"input\",\n\t\"label\",\n\t\"legend\",\n\t\"meter\",\n\t\"optgroup\",\n\t\"option\",\n\t\"output\",\n\t\"progress\",\n\t\"select\",\n\t\"textarea\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tdetails: Child;\n\t\tdialog: Child;\n\t\tmenu: Child;\n\t\tsummary: Child;\n\t\tcanvas: Child;\n\t\tscript: Child;\n\t\tnoscript: Child;\n\t\tslot: Child;\n\t\ttemplate: Child;\n\t}\n}\n\nconst nodes = [\n\t\"details\",\n\t\"dialog\",\n\t\"menu\",\n\t\"summary\",\n\t\"canvas\",\n\t\"script\",\n\t\"noscript\",\n\t\"slot\",\n\t\"template\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tarea: Child;\n\t\taudio: Child;\n\t\timg: Child;\n\t\ttrack: Child;\n\t\tvideo: Child;\n\t}\n}\n\nconst nodes = [\"area\", \"audio\", \"img\", \"track\", \"video\"];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\taddress: Child;\n\t\tarticle: Child;\n\t\taside: Child;\n\t\tfooter: Child;\n\t\theader: Child;\n\t\th1: Child;\n\t\th2: Child;\n\t\th3: Child;\n\t\th4: Child;\n\t\th5: Child;\n\t\th6: Child;\n\t\thgroup: Child;\n\t\tmain: Child;\n\t\tnav: Child;\n\t\tsection: Child;\n\t}\n}\n\nconst nodes = [\n\t\"address\",\n\t\"article\",\n\t\"aside\",\n\t\"footer\",\n\t\"header\",\n\t\"h1\",\n\t\"h2\",\n\t\"h3\",\n\t\"h4\",\n\t\"h5\",\n\t\"h6\",\n\t\"hgroup\",\n\t\"main\",\n\t\"nav\",\n\t\"section\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tcaption: Child;\n\t\tcol: Child;\n\t\tcolgroup: Child;\n\t\ttable: Child;\n\t\ttbody: Child;\n\t\ttd: Child;\n\t\ttfoot: Child;\n\t\tth: Child;\n\t\tthead: Child;\n\t\ttr: Child;\n\t}\n}\n\nconst nodes = [\n\t\"caption\",\n\t\"col\",\n\t\"colgroup\",\n\t\"table\",\n\t\"tbody\",\n\t\"td\",\n\t\"tfoot\",\n\t\"th\",\n\t\"thead\",\n\t\"tr\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tdel: Child;\n\t\tins: Child;\n\t\ta: Child;\n\t\tabbr: Child;\n\t\tb: Child;\n\t\tbdi: Child;\n\t\tbdo: Child;\n\t\tbr: Child;\n\t\tcite: Child;\n\t\tcode: Child;\n\t\tdata: Child;\n\t\tdfn: Child;\n\t\tem: Child;\n\t\ti: Child;\n\t\tkbd: Child;\n\t\tmark: Child;\n\t\tq: Child;\n\t\trb: Child;\n\t\trp: Child;\n\t\trt: Child;\n\t\trtc: Child;\n\t\truby: Child;\n\t\ts: Child;\n\t\tsamp: Child;\n\t\tsmall: Child;\n\t\tspan: Child;\n\t\tstrong: Child;\n\t\tsub: Child;\n\t\tsup: Child;\n\t\ttime: Child;\n\t\tu: Child;\n\t\tvar: Child;\n\t\twbr: Child;\n\t}\n}\n\nconst nodes = [\n\t\"del\",\n\t\"ins\",\n\t\"a\",\n\t\"abbr\",\n\t\"b\",\n\t\"bdi\",\n\t\"bdo\",\n\t\"br\",\n\t\"cite\",\n\t\"code\",\n\t\"data\",\n\t\"dfn\",\n\t\"em\",\n\t\"i\",\n\t\"kbd\",\n\t\"mark\",\n\t\"q\",\n\t\"rb\",\n\t\"rp\",\n\t\"rt\",\n\t\"rtc\",\n\t\"ruby\",\n\t\"s\",\n\t\"samp\",\n\t\"small\",\n\t\"span\",\n\t\"strong\",\n\t\"sub\",\n\t\"sup\",\n\t\"time\",\n\t\"u\",\n\t\"var\",\n\t\"wbr\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { IsotopeNode } from \"../node\";\n\ninterface IsotopeViewConfig {\n\tattach?: boolean;\n\tclean?: boolean;\n}\n\n/**\n * Creates a DOM View.\n *\n * @param element - Element to append to.\n * @param config - DOM View config.\n * @returns - The created top-level Node.\n */\nconst createDOMView = (element: Element, config?: IsotopeViewConfig): IsotopeNode => {\n\tif (IsotopeNode.prototype.customDOM) {\n\t\tIsotopeNode.prototype.customDOM = null;\n\t}\n\n\tif (!config || (config && config.clean && !config.attach)) {\n\t\telement.textContent = \"\";\n\t}\n\n\treturn new IsotopeNode(element, config);\n};\n\nexport { createDOMView };\n","import { CustomEvent } from \"../../declarations\";\nimport { IsotopeNode } from \"../../node\";\nimport { StringElement } from \"./element\";\n\n/**\n * Creates a String View.\n *\n * @param tag - Tag for the top-level Node.\n * @returns - The created top-level Node.\n */\nconst createStringView = (tag: string): IsotopeNode => {\n\tif (!IsotopeNode.prototype.customDOM) {\n\t\tIsotopeNode.prototype.customDOM = {\n\t\t\t/** @private */\n\t\t\tcreateElement(tag: string): StringElement {\n\t\t\t\treturn new StringElement(tag);\n\t\t\t},\n\t\t\t/** @private */\n\t\t\tcreateEvent(type: string): CustomEvent {\n\t\t\t\treturn { type };\n\t\t\t}\n\t\t};\n\t}\n\n\treturn new IsotopeNode(tag);\n};\n\nexport { createStringView };\n"],"names":["IsotopeNode","[object Object]","element","config","this","getElement","textContent","attach","childIndex","autoLink","state","context","onCreate","forEach","callback","process","directives","Array","isArray","directive","node","tag","shouldAttach","attachTarget","children","appendChild","Object","assign","link","linked","onClean","event","data","dispatchEvent","customDOM","createEvent","Event","key","position","nodeLinkup","linkup","splice","indexOf","push","upperLinked","referenceNode","insertBefore","handler","options","removeEventListener","addEventListener","parentElement","removeChild","emit","namespace","createElement","document","createElementNS","onProcess","prototype","StringElement","add","tokens","classes","contains","token","includes","remove","tagName","type","listener","events","newChild","slice","handleEvent","qualifiedName","attributes","refChild","index","oldChild","value","$textContent","content","map","child","join","styles","entries","style","property","replace","match","toLowerCase","name","setAttribs","attribs","attrib","getAttribute","setAttribute","removeAttribute","setAttrib","setClasses","className","classList","addClass","removeClass","setStyles","setStyle","if","processConditional","conditionalData","condition","processedCondition","Boolean","getState","previous","onTrue","onFalse","clean","shouldLoop","source","target","length","trim","sourceStart","sourceEnd","targetStart","targetEnd","trimmed","shift","pop","prepareMove","moveRight","left","right","move","changes","itemToLeft","itemToRight","id","handleMapUpdate","items","mapData","sourceInput","targetInput","item","createData","change","findIndex","fill","detectChanges","createItem","find","handleMapCreation","processMap","text","processText","textData","registerChild"],"mappings":"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A,SACA,SACA,WACA,OACA,YAGKhF,QAASgF,IACdiE,EAAcjE,KCjBD,CAAC,OAAQ,QAAS,MAAO,QAAS,SAE1ChF,QAASgF,IACdiE,EAAcjE,KCOD,CACb,UACA,UACA,QACA,SACA,SACA,KACA,KACA,KACA,KACA,KACA,KACA,SACA,OACA,MACA,WAGKhF,QAASgF,IACdiE,EAAcjE,KCxBD,CACb,UACA,MACA,WACA,QACA,QACA,KACA,QACA,KACA,QACA,MAGKhF,QAASgF,IACdiE,EAAcjE,KCSD,CACb,MACA,MACA,IACA,OACA,IACA,MACA,MACA,KACA,OACA,OACA,OACA,MACA,KACA,IACA,MACA,OACA,IACA,KACA,KACA,KACA,MACA,OACA,IACA,OACA,QACA,OACA,SACA,MACA,MACA,OACA,IACA,MACA,OAGKhF,QAASgF,IACdiE,EAAcjE,qCC/DO,EAAC3F,EAAkBC,KACpCH,EAAY2D,UAAUzB,YACzBlC,EAAY2D,UAAUzB,UAAY,QAG9B/B,GAAWA,GAAUA,EAAOmH,QAAUnH,EAAOI,UACjDL,EAAQI,YAAc,IAGhB,IAAIN,EAAYE,EAASC,wBCbR,CAACkB,IACpBrB,EAAY2D,UAAUzB,YAC1BlC,EAAY2D,UAAUzB,UAAY,CAEjCqB,cAAclC,GACN,IAAIuC,EAAcvC,GAG1Bc,YAAYkC,IACJ,CAAEA,KAAAA,MAKL,IAAIrE,EAAYqB"}