{"version":3,"file":"isotope.min.js","sources":["../src/node.ts","../src/nodes/conditional.ts","../src/configurators/attribs.ts","../src/configurators/classes.ts","../src/configurators/styles.ts","../src/utils.ts","../src/nodes/map.ts","../src/nodes/text.ts","../src/nodes/html/register.ts","../src/nodes/html/content.ts","../src/nodes/html/embed.ts","../src/nodes/html/form.ts","../src/nodes/html/interactive.ts","../src/nodes/html/media.ts","../src/nodes/html/section.ts","../src/nodes/html/table.ts","../src/nodes/html/text.ts","../src/view.ts"],"sourcesContent":["import { CustomDOM, CustomElement, Indexable } from \"./declarations\";\n\ninterface IsotopeNodeConfig<S extends Indexable, C extends Indexable> {\n\tnamespace?: string;\n\tautoLink?: boolean;\n\tattach?: boolean;\n\tcontext?: C;\n\tstate?: S;\n}\n\ninterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\tonCreate: Array<(node: this, config: IsotopeNodeConfig<S, C>) => void>;\n\tonProcess: Array<(node: this) => void>;\n\tonClean: Array<(node: this) => void>;\n\tcustomDOM?: CustomDOM | null;\n}\n\ntype Directive<S extends Indexable, C extends Indexable, R extends void | any> = (\n\tnode: IsotopeNode<S, C>\n) => R;\n\n/**\n * Class representing a Node.\n */\nclass IsotopeNode<S extends Indexable = any, C extends Indexable = any>\n\timplements IsotopeNode<S, C> {\n\tpublic state?: S;\n\n\tpublic context?: C;\n\n\tpublic id?: string;\n\n\tpublic linked?: IsotopeNode[] | null;\n\n\tpublic element: CustomElement;\n\n\tprotected linkup?: IsotopeNode | null;\n\n\tprotected childIndex?: number;\n\n\tprotected autoLink?: boolean;\n\n\tprotected listenedEvents?: string[];\n\n\t/**\n\t * Creates a new Node.\n\t *\n\t * @param element -  The Node's HTML element or tag.\n\t * @param config - The Node's configuration.\n\t */\n\tpublic constructor(\n\t\telement: string | CustomElement | Element,\n\t\tconfig?: IsotopeNodeConfig<S, C> | string\n\t) {\n\t\tthis.element = this.getElement(element, config);\n\n\t\tif (typeof config === \"string\") {\n\t\t\tthis.element.textContent = config;\n\t\t} else if (typeof config === \"object\") {\n\t\t\tif (config.attach) {\n\t\t\t\tthis.childIndex = 0;\n\t\t\t}\n\n\t\t\tif (config.autoLink) {\n\t\t\t\tthis.autoLink = config.autoLink;\n\t\t\t}\n\n\t\t\tif (config.state) {\n\t\t\t\tthis.state = config.state;\n\t\t\t}\n\n\t\t\tif (config.context) {\n\t\t\t\tthis.context = config.context;\n\t\t\t}\n\n\t\t\tthis.onCreate.forEach((callback) => {\n\t\t\t\tcallback(this, config);\n\t\t\t});\n\t\t}\n\n\t\tthis.process();\n\t}\n\n\t/**\n\t * Executes the provided directive(s).\n\t *\n\t * @param directives - Directive(s) to be executed.\n\t * @returns - The Node or the return value of the directive.\n\t */\n\tpublic $<R extends void | any>(\n\t\tdirectives: Directive<S, C, R> | Array<Directive<S, C, void>>\n\t): R extends void ? this : R {\n\t\tif (Array.isArray(directives)) {\n\t\t\tdirectives.forEach((directive) => {\n\t\t\t\tdirective(this);\n\t\t\t});\n\t\t} else {\n\t\t\tconst value = directives(this);\n\n\t\t\tif (typeof value !== \"undefined\") {\n\t\t\t\treturn value as R extends void ? this : R;\n\t\t\t}\n\t\t}\n\n\t\treturn this as R extends void ? this : R;\n\t}\n\n\t/**\n\t * Adds a child Node to the Node.\n\t *\n\t * @param tag - Child Node's HTML tag.\n\t * @param config - Child Node's configuration.\n\t * @returns - The created child Node.\n\t */\n\tpublic child<S2 extends Indexable = Indexable, C2 extends Indexable = Indexable>(\n\t\ttag: string,\n\t\tconfig?:\n\t\t\t| IsotopeNodeConfig<S2, Partial<C> & C2>\n\t\t\t| string\n\t\t\t| Directive<S2, Partial<C> & C2, void>\n\t\t\t| Array<Directive<S2, Partial<C> & C2, void>>\n\t): IsotopeNode<S2, Partial<C> & C2> {\n\t\tconst shouldAttach = typeof this.childIndex !== \"undefined\";\n\t\tconst isConfigDirective = typeof config === \"function\" || Array.isArray(config);\n\n\t\tlet element: CustomElement | Element | string = tag;\n\n\t\tif (shouldAttach) {\n\t\t\tconst index = this.childIndex || 0;\n\t\t\tconst attachTarget = this.element.children[index];\n\n\t\t\tif (attachTarget) {\n\t\t\t\telement = attachTarget;\n\t\t\t\tthis.childIndex = index + 1;\n\t\t\t}\n\t\t}\n\n\t\tconst node = new IsotopeNode<S2, Partial<C> & C2>(\n\t\t\telement,\n\t\t\tisConfigDirective ? {} : (config as string | IsotopeNodeConfig<S2, Partial<C> & C2>)\n\t\t);\n\n\t\tthis.element.appendChild(node.element);\n\n\t\tif (shouldAttach && !node.childIndex) {\n\t\t\tnode.childIndex = 0;\n\t\t}\n\n\t\tthis.passContext(node);\n\n\t\tif (this.autoLink) {\n\t\t\tthis.link(node);\n\t\t}\n\n\t\tif (isConfigDirective) {\n\t\t\tthis.$(\n\t\t\t\tconfig as\n\t\t\t\t\t| Directive<S2, Partial<C> & C2, void>\n\t\t\t\t\t| Array<Directive<S2, Partial<C> & C2, void>>\n\t\t\t);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Cleans the Node's child tree.\n\t *\n\t * @returns - IsotopeNode.\n\t */\n\tpublic clean(): this {\n\t\tif (this.linked) {\n\t\t\tthis.linked = null;\n\t\t}\n\n\t\tthis.onClean.forEach((callback) => {\n\t\t\tcallback(this);\n\t\t});\n\t\tthis.element.textContent = \"\";\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Emits the specified event.\n\t *\n\t * @param event - Event to be emitted.\n\t * @param data - Data to be passed to the listening function.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic emit(event: string, data: object = {}): this {\n\t\tif (this.listenedEvents && this.listenedEvents.includes(event)) {\n\t\t\tthis.element.dispatchEvent(\n\t\t\t\tObject.assign(\n\t\t\t\t\tthis.customDOM ? this.customDOM.createEvent(event) : new Event(event),\n\t\t\t\t\tdata\n\t\t\t\t)\n\t\t\t);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Retrieves the data from the Node's context.\n\t *\n\t * @param key - Data key to be retrieved.\n\t * @returns - The retrieved data.\n\t */\n\tpublic getContext<K extends keyof C>(key: K): C[K] | null {\n\t\treturn this.context ? this.context[key] : null;\n\t}\n\n\t/**\n\t * Retrieves the data from the Node's state.\n\t *\n\t * @param key - Data key to be retrieved.\n\t * @returns - The retrieved data.\n\t */\n\tpublic getState<K extends keyof S>(key: K): S[K] | null {\n\t\treturn this.state ? this.state[key] : null;\n\t}\n\n\t/**\n\t * Links the provided Node.\n\t *\n\t * @param node - Node to be linked.\n\t * @param position - Position to place Node at in the linked array.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic link(node: IsotopeNode, position?: number): this {\n\t\tconst nodeLinkup = node.linkup;\n\n\t\tif (nodeLinkup !== this) {\n\t\t\tif (nodeLinkup && nodeLinkup.linked) {\n\t\t\t\tnodeLinkup.linked.splice(nodeLinkup.linked.indexOf(node), 1);\n\t\t\t}\n\n\t\t\tif (!this.linked) {\n\t\t\t\tthis.linked = [];\n\t\t\t}\n\n\t\t\tif (position) {\n\t\t\t\tthis.linked.splice(position, 0, node);\n\t\t\t} else {\n\t\t\t\tthis.linked.push(node);\n\t\t\t}\n\n\t\t\tnode.linkup = this;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Moves the linked Node to the provided position.\n\t *\n\t * @param position - Position index to move the Node to.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic move(position: number): this {\n\t\tconst { linkup } = this;\n\n\t\tif (linkup && linkup.linked) {\n\t\t\tconst upperLinked = linkup.linked;\n\t\t\tconst [node] = upperLinked.splice(upperLinked.indexOf(this as any), 1);\n\n\t\t\tupperLinked.splice(position, 0, node);\n\n\t\t\tconst referenceNode = upperLinked[position + 1];\n\n\t\t\tlinkup.element.insertBefore(\n\t\t\t\tthis.element,\n\t\t\t\treferenceNode ? referenceNode.element : null\n\t\t\t);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Disables the specified event listener.\n\t *\n\t * @param event - Event to disable the listener for.\n\t * @param handler - Event handler to be disabled.\n\t * @param options - Event listening options.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic off<K extends keyof HTMLElementEventMap>(\n\t\tevent: K | string,\n\t\thandler: (ev: HTMLElementEventMap[K]) => any,\n\t\toptions?: boolean | EventListenerOptions\n\t): this;\n\n\t/** @private */\n\tpublic off(\n\t\tevent: string,\n\t\thandler: EventListenerOrEventListenerObject,\n\t\toptions?: boolean | EventListenerOptions\n\t): this {\n\t\tthis.element.removeEventListener(event, handler, options);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Setups an event listener for the specified event.\n\t *\n\t * @param event - Event to be listened to.\n\t * @param handler - Event handling function.\n\t * @param options - Event listening options.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic on<K extends keyof HTMLElementEventMap>(\n\t\tevent: K | string,\n\t\thandler: (data: HTMLElementEventMap[K]) => void,\n\t\toptions?: boolean | AddEventListenerOptions\n\t): this;\n\n\t/** @private */\n\tpublic on(\n\t\tevent: string,\n\t\thandler: EventListenerOrEventListenerObject,\n\t\toptions?: boolean | AddEventListenerOptions\n\t): this {\n\t\tthis.element.addEventListener(event, handler, options);\n\n\t\tif (this.listenedEvents) {\n\t\t\tthis.listenedEvents.push(event);\n\t\t} else {\n\t\t\tthis.listenedEvents = [event];\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes the Node.\n\t *\n\t * @returns - IsotopeNode.\n\t */\n\tpublic remove(): this {\n\t\tconst { linkup } = this;\n\n\t\tif (linkup && linkup.linked) {\n\t\t\tlinkup.linked.splice(linkup.linked.indexOf(this as any), 1);\n\t\t}\n\n\t\tif (this.linked) {\n\t\t\tthis.linked = null;\n\t\t}\n\n\t\tif (this.element.parentElement) {\n\t\t\tthis.element.parentElement.removeChild(this.element);\n\t\t}\n\n\t\tthis.emit(\"node-removed\", { node: this });\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the Node's state.\n\t *\n\t * @param state - State object to be set.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic setState(state: Partial<S>): this {\n\t\tif (this.state) {\n\t\t\tObject.assign(this.state, state);\n\t\t\tthis.emit(\"state-changed\", { node: this });\n\t\t\tthis.process();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stringifies Node's element.\n\t *\n\t * @returns - Stringified Node's element.\n\t */\n\tpublic toString(): string {\n\t\treturn `${this.element}`;\n\t}\n\n\t/**\n\t * Retrieves the proper element from Node's configuration.\n\t *\n\t * @param element -  The Node's element or tag.\n\t * @param config - The Node's configuration.\n\t * @returns - Retrieved element.\n\t */\n\tprotected getElement(\n\t\telement: string | CustomElement | Element,\n\t\tconfig?:\n\t\t\t| IsotopeNodeConfig<S, C>\n\t\t\t| string\n\t\t\t| Directive<S, C, void>\n\t\t\t| Array<Directive<S, C, void>>\n\t): CustomElement {\n\t\tif (typeof element === \"string\") {\n\t\t\tif (typeof config === \"object\" && !Array.isArray(config) && config.namespace) {\n\t\t\t\tif (this.customDOM) {\n\t\t\t\t\treturn this.customDOM.createElement(element, config.namespace);\n\t\t\t\t}\n\n\t\t\t\treturn (document.createElementNS(\n\t\t\t\t\tconfig.namespace,\n\t\t\t\t\telement\n\t\t\t\t) as any) as CustomElement;\n\t\t\t} else if (this.customDOM) {\n\t\t\t\treturn this.customDOM.createElement(element);\n\t\t\t}\n\n\t\t\treturn (document.createElement(element) as any) as CustomElement;\n\t\t}\n\n\t\treturn element as CustomElement;\n\t}\n\n\t/**\n\t * Passes context to the child node.\n\t *\n\t * @param node - Node to pass the context to.\n\t */\n\tprotected passContext(node: IsotopeNode): void {\n\t\tif (this.context) {\n\t\t\tif (node.context) {\n\t\t\t\tnode.context = Object.assign(node.context, this.context);\n\t\t\t} else {\n\t\t\t\tnode.context = this.context;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Processes and renders the Node.\n\t */\n\tprotected process(): void {\n\t\tthis.emit(\"node-updated\", { node: this });\n\t\tthis.onProcess.forEach((callback) => {\n\t\t\tcallback(this);\n\t\t});\n\n\t\tif (this.linked) {\n\t\t\tthis.linked.forEach((linked) => {\n\t\t\t\tlinked.process();\n\t\t\t});\n\t\t}\n\t}\n}\n\nObject.assign(IsotopeNode.prototype, {\n\tonClean: [],\n\tonCreate: [],\n\tonProcess: []\n});\n\nexport { Directive, IsotopeNode, IsotopeNodeConfig };\n","import { Indexable } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\n\ninterface ConditionalData<S extends Indexable, C extends Indexable> {\n\tprevious?: boolean;\n\tcondition: keyof S | ((node: IsotopeNode<S, C>) => boolean);\n\tonTrue(node: IsotopeNode<S, C>): IsotopeNode | void;\n\tonFalse?(node: IsotopeNode<S, C>): IsotopeNode | void;\n}\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\tconditionalData?: ConditionalData<S, C> | null;\n\t\t/**\n\t\t * Conditionally renders the provided nodes.\n\t\t *\n\t\t * @param condition - Condition to be checked.\n\t\t * @param onTrue - Rendering function to be executed when condition is truthy.\n\t\t * @param onFalse - Rendering function to be executed when condition is falsy.\n\t\t * @returns - The Node.\n\t\t */\n\t\tif(\n\t\t\tcondition: boolean | keyof S | ((node: this) => boolean),\n\t\t\tonTrue: (node: this) => IsotopeNode | void,\n\t\t\tonFalse?: (node: this) => IsotopeNode | void\n\t\t): this;\n\t}\n}\n\nif (!IsotopeNode.prototype.if) {\n\t/**\n\t * Processes the provided Node's conditional child tree.\n\t *\n\t * @param node - Node to be processed.\n\t */\n\tconst processConditional = (node: IsotopeNode): void => {\n\t\tif (node.conditionalData) {\n\t\t\tconst data = node.conditionalData;\n\t\t\tconst { condition } = data;\n\t\t\tconst processedCondition = Boolean(\n\t\t\t\ttypeof condition === \"function\" ? condition(node) : node.getState(condition)\n\t\t\t);\n\n\t\t\tif (processedCondition !== data.previous) {\n\t\t\t\tnode.element.textContent = \"\";\n\t\t\t\tnode.linked = null;\n\n\t\t\t\tif (processedCondition) {\n\t\t\t\t\tdata.onTrue(node);\n\t\t\t\t} else if (data.onFalse) {\n\t\t\t\t\tdata.onFalse(node);\n\t\t\t\t}\n\n\t\t\t\tdata.previous = processedCondition;\n\t\t\t}\n\t\t}\n\t};\n\n\tIsotopeNode.prototype.onClean.push((node) => {\n\t\tif (node.conditionalData) {\n\t\t\tnode.conditionalData = null;\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.conditionalData) {\n\t\t\tprocessConditional(node);\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\tif(\n\t\t\tthis: IsotopeNode,\n\t\t\tcondition: boolean | string | ((node: IsotopeNode) => boolean),\n\t\t\tonTrue: (node: IsotopeNode) => IsotopeNode | void,\n\t\t\tonFalse?: (node: IsotopeNode) => IsotopeNode | void\n\t\t): IsotopeNode {\n\t\t\tthis.clean();\n\n\t\t\tif (typeof condition === \"boolean\") {\n\t\t\t\tif (condition) {\n\t\t\t\t\tonTrue(this);\n\t\t\t\t} else if (onFalse) {\n\t\t\t\t\tonFalse(this);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.conditionalData = {\n\t\t\t\t\tcondition,\n\t\t\t\t\tonFalse,\n\t\t\t\t\tonTrue\n\t\t\t\t};\n\t\t\t\tprocessConditional(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","import { ConfigFunction, Indexable } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\tattribs?: ConfigFunction<S, C, Indexable<string | boolean>>;\n\t\t/**\n\t\t * Retrieves the value of the specified attribute.\n\t\t *\n\t\t * @param attrib - Attribute to be retrieved.\n\t\t * @returns - The retrieved value.\n\t\t */\n\t\tgetAttrib(attrib: string): string | boolean | null;\n\t\t/**\n\t\t * Sets the value of the specified attribute.\n\t\t *\n\t\t * @param attrib - Attribute to be set.\n\t\t * @param value - Value to assigned.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tsetAttrib(attrib: string, value?: string | boolean): this;\n\t\t/**\n\t\t * Sets multiple attributes.\n\t\t *\n\t\t * @param attribs - Object with key-value pairs of attributes and their values.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tsetAttribs(attribs: Indexable): this;\n\t}\n\tinterface IsotopeNodeConfig<S extends Indexable, C extends Indexable> {\n\t\tattribs?: Indexable | ConfigFunction<S, C, Indexable>;\n\t}\n}\n\nif (!IsotopeNode.prototype.setAttribs) {\n\tIsotopeNode.prototype.onCreate.push((node, config) => {\n\t\tif (config.attribs) {\n\t\t\tif (typeof config.attribs === \"function\") {\n\t\t\t\tnode.attribs = config.attribs as ConfigFunction<\n\t\t\t\t\tany,\n\t\t\t\t\tany,\n\t\t\t\t\tIndexable<string | boolean>\n\t\t\t\t>;\n\t\t\t} else {\n\t\t\t\tnode.setAttribs(config.attribs);\n\t\t\t}\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.attribs) {\n\t\t\tnode.setAttribs(node.attribs(node));\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\tgetAttrib(this: IsotopeNode, attrib: string): string | boolean | null {\n\t\t\tconst value = this.element.getAttribute(attrib);\n\n\t\t\treturn value === \"\" ? true : value;\n\t\t},\n\t\t/** @private */\n\t\tsetAttrib(this: IsotopeNode, attrib: string, value?: string | boolean): IsotopeNode {\n\t\t\tif (value) {\n\t\t\t\tthis.element.setAttribute(attrib, value === true ? \"\" : value);\n\t\t\t} else {\n\t\t\t\tthis.element.removeAttribute(attrib);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t/** @private */\n\t\tsetAttribs(this: IsotopeNode, attribs: Indexable): IsotopeNode {\n\t\t\tObject.entries(attribs).forEach(([attrib, value]) => {\n\t\t\t\tthis.setAttrib(attrib, value);\n\t\t\t});\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","import { ConfigFunction, Indexable } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\tclasses?: ConfigFunction<S, C, string[] | Indexable<boolean>>;\n\t\t/**\n\t\t * Applies the specified CSS class name to the Node's element.\n\t\t *\n\t\t * @param className - CSS class name to be applied.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\taddClass(className: string): this;\n\t\t/**\n\t\t * Checks if the Node's element contains the specified CSS class name.\n\t\t *\n\t\t * @param className - CSS class name to be checked.\n\t\t * @returns - If the Node's element contains the specified CSS class name.\n\t\t */\n\t\thasClass(className: string): boolean;\n\t\t/**\n\t\t * Removes the specified CSS class name from the Node's element.\n\t\t *\n\t\t * @param className - CSS class name to be removed.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tremoveClass(className: string): this;\n\t\t/**\n\t\t * Sets multiple CSS class names.\n\t\t *\n\t\t * @param classes - Object or array with CSS class name to be set.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tsetClasses(classes: string[] | Indexable<boolean>): this;\n\t}\n\tinterface IsotopeNodeConfig<S extends Indexable, C extends Indexable> {\n\t\tclasses?:\n\t\t\t| string[]\n\t\t\t| Indexable<boolean>\n\t\t\t| ConfigFunction<S, C, Indexable<boolean> | string[]>;\n\t}\n}\n\nif (!IsotopeNode.prototype.setClasses) {\n\tIsotopeNode.prototype.onCreate.push((node, config) => {\n\t\tif (config.classes) {\n\t\t\tlet classes = \"\";\n\n\t\t\tif (typeof config.classes === \"function\") {\n\t\t\t\tnode.classes = config.classes;\n\t\t\t} else if (Array.isArray(config.classes)) {\n\t\t\t\tclasses = config.classes.join(\" \");\n\t\t\t} else {\n\t\t\t\tclasses = Object.entries(config.classes)\n\t\t\t\t\t.filter(([, apply]) => apply)\n\t\t\t\t\t.map(([name]) => name)\n\t\t\t\t\t.join(\" \");\n\t\t\t}\n\n\t\t\tif (classes) {\n\t\t\t\tnode.element.setAttribute(\"class\", classes);\n\t\t\t}\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.classes) {\n\t\t\tnode.setClasses(node.classes(node));\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\taddClass(this: IsotopeNode, className: string): IsotopeNode {\n\t\t\tthis.element.classList.add(className);\n\n\t\t\treturn this;\n\t\t},\n\t\t/** @private */\n\t\thasClass(this: IsotopeNode, className: string): boolean {\n\t\t\treturn this.element.classList.contains(className);\n\t\t},\n\t\t/** @private */\n\t\tremoveClass(this: IsotopeNode, className: string): IsotopeNode {\n\t\t\tthis.element.classList.remove(className);\n\n\t\t\treturn this;\n\t\t},\n\t\t/** @private */\n\t\tsetClasses(this: IsotopeNode, classes: string[] | Indexable<boolean>): IsotopeNode {\n\t\t\tif (Array.isArray(classes)) {\n\t\t\t\tclasses.forEach((className) => this.addClass(className));\n\t\t\t} else {\n\t\t\t\tObject.entries(classes).forEach(([className, value]) => {\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tthis.addClass(className);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.removeClass(className);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","import { ConfigFunction, Indexable, StyleProperties } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\tstyles?: ConfigFunction<S, C, StyleProperties>;\n\t\t/**\n\t\t * Retrieves the value of the specified style property.\n\t\t *\n\t\t * @param property - Property to be retrieved.\n\t\t * @returns - The retrieved value.\n\t\t */\n\t\tgetStyle<P extends keyof StyleProperties>(\n\t\t\tproperty: P\n\t\t): StyleProperties[P] | undefined;\n\t\t/**\n\t\t * Sets the specified style property.\n\t\t *\n\t\t * @param property - Property to be set.\n\t\t * @param value - Value to be assigned.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tsetStyle<P extends keyof StyleProperties>(\n\t\t\tproperty: P,\n\t\t\tvalue: StyleProperties[P]\n\t\t): this;\n\t\t/**\n\t\t * Sets multiple style properties.\n\t\t *\n\t\t * @param styles - Object with style properties to be set.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tsetStyles(this: IsotopeNode, styles: StyleProperties): this;\n\t}\n\tinterface IsotopeNodeConfig<S extends Indexable, C extends Indexable> {\n\t\tstyles?: StyleProperties | ConfigFunction<S, C, StyleProperties>;\n\t}\n}\n\nif (!IsotopeNode.prototype.setStyles) {\n\tIsotopeNode.prototype.onCreate.push((node, config) => {\n\t\tif (config.styles) {\n\t\t\tif (typeof config.styles === \"function\") {\n\t\t\t\tnode.styles = config.styles;\n\t\t\t} else {\n\t\t\t\tnode.setStyles(config.styles);\n\t\t\t}\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.styles) {\n\t\t\tnode.setStyles(node.styles(node));\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\tgetStyle<P extends keyof StyleProperties>(\n\t\t\tthis: IsotopeNode,\n\t\t\tproperty: P\n\t\t): StyleProperties[P] | undefined {\n\t\t\tconst { style } = this.element;\n\n\t\t\treturn style ? style[property] : style;\n\t\t},\n\t\t/** @private */\n\t\tsetStyle<P extends keyof StyleProperties>(\n\t\t\tthis: IsotopeNode,\n\t\t\tproperty: P,\n\t\t\tvalue: StyleProperties[P]\n\t\t): IsotopeNode {\n\t\t\tconst { style } = this.element;\n\n\t\t\tif (style) {\n\t\t\t\tstyle[property] = `${value}${typeof value === \"number\" ? \"px\" : \"\"}` as any;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\t\t/** @private */\n\t\tsetStyles(this: IsotopeNode, styles: StyleProperties): IsotopeNode {\n\t\t\tObject.entries(styles).forEach(\n\t\t\t\t([property, value]: [keyof StyleProperties, string | number]) => {\n\t\t\t\t\tthis.setStyle(property, value);\n\t\t\t\t}\n\t\t\t);\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","interface Change {\n\tid: SimpleItem;\n\titem?: Item;\n\tposition?: number;\n\ttype: \"add\" | \"remove\" | \"move\";\n}\n\ninterface DiffingData {\n\tchanges: Change[];\n\tindex: number;\n\tsource: SimpleItem[];\n\tsourceInput: Item[];\n\ttarget: SimpleItem[];\n\ttargetInput: Item[];\n}\n\ninterface MoveData {\n\tleft: SimpleItem | null;\n\tright: SimpleItem | null;\n}\n\ntype SimpleItem = string | number;\n\ntype Item = string | number | { id: string | number };\n\n/**\n * Creates the Diffing loop data object.\n *\n * @param sourceInput - Original, source Item array.\n * @param targetInput - Target Item array.\n * @returns - Diffing loop data object.\n */\nconst createData = (sourceInput: Item[], targetInput: Item[]): DiffingData => ({\n\tchanges: [],\n\tindex: 0,\n\tsource: sourceInput.map((item) => `${typeof item === \"object\" ? item.id : item}`),\n\tsourceInput,\n\ttarget: targetInput.map((item) => `${typeof item === \"object\" ? item.id : item}`),\n\ttargetInput\n});\n/**\n * Checks if the diffing loop should be run.\n *\n * @param data - Diffing loop data.\n * @returns - If the diffing loop should be run.\n */\nconst shouldLoop = ({ index, source, target }: DiffingData): boolean => {\n\treturn (\n\t\tsource.length > 0 &&\n\t\ttarget.length > 0 &&\n\t\t(index <= source.length || index <= target.length)\n\t);\n};\n/**\n * Trims the diffed arrays from both sides if edge items are equal.\n *\n * @param data - Diffing loop data.\n * @returns - If arrays were trimmed.\n */\nconst trim = ({ source, target }: DiffingData): boolean => {\n\tconst [sourceStart] = source;\n\tconst sourceEnd = source[source.length - 1];\n\tconst [targetStart] = target;\n\tconst targetEnd = target[target.length - 1];\n\n\tlet trimmed = false;\n\n\tif (sourceStart === targetStart) {\n\t\tsource.shift();\n\t\ttarget.shift();\n\t\ttrimmed = true;\n\t}\n\n\tif (sourceEnd === targetEnd) {\n\t\tsource.pop();\n\t\ttarget.pop();\n\t\ttrimmed = true;\n\t}\n\n\treturn trimmed;\n};\n/**\n * Detect whether the items should be moved to the opposite site of the array.\n *\n * @param data - Diffing loop data.\n * @returns - Which item should be moved to left and which to right.\n */\nconst prepareMove = ({ index, source, target }: DiffingData): MoveData => {\n\tconst sourceStart = source[index];\n\tconst sourceEnd = source[source.length - 1 - index];\n\tconst [targetStart] = target;\n\tconst targetEnd = target[target.length - 1];\n\tconst moveLeft = sourceEnd === targetStart;\n\tconst moveRight = sourceStart === targetEnd;\n\tconst itemToLeft = moveLeft ? source.splice(source.length - 1 - index, 1)[0] : null;\n\tconst itemToRight = moveRight ? source.splice(index, 1)[0] : null;\n\n\treturn {\n\t\tleft: itemToLeft,\n\t\tright: itemToRight\n\t};\n};\n/**\n * Move the specified items to the opposite site of the array.\n *\n * @param data - Diffing loop data.\n * @param itemToLeft - Item to be moved to the left end.\n * @param itemToRight - Item to be moved to the right end.\n */\nconst move = (\n\t{ changes, source }: DiffingData,\n\titemToLeft: SimpleItem | null,\n\titemToRight: SimpleItem | null\n): void => {\n\tif (itemToRight !== null) {\n\t\tsource.push(itemToRight);\n\t\tchanges.push({\n\t\t\tid: itemToRight,\n\t\t\ttype: \"move\"\n\t\t});\n\t}\n\n\tif (itemToLeft !== null) {\n\t\tsource.splice(0, 0, itemToLeft);\n\t\tchanges.push({\n\t\t\tid: itemToLeft,\n\t\t\ttype: \"move\"\n\t\t});\n\t}\n};\n/**\n * Adds the new items from diffed arrays.\n *\n * @param data - Diffing loop data.\n */\nconst add = ({ changes, target }: DiffingData): void => {\n\ttarget.splice(0).forEach((id) => {\n\t\tchanges.push({\n\t\t\tid,\n\t\t\ttype: \"add\"\n\t\t});\n\t});\n};\n/**\n * Removes the previous items from diffed arrays.\n *\n * @param data - Diffing loop data.\n */\nconst remove = ({ changes, source }: DiffingData): void => {\n\tsource.splice(0).forEach((id) => {\n\t\tchanges.push({\n\t\t\tid,\n\t\t\ttype: \"remove\"\n\t\t});\n\t});\n};\n/**\n * Fills the remaining data required by specific changes.\n *\n * @param data - Diffing loop data.\n */\nconst fill = ({ changes, targetInput }: DiffingData): void => {\n\tchanges.forEach((change) => {\n\t\tconst id = `${change.id}`;\n\t\tconst { type } = change;\n\n\t\tif (type === \"add\" || type === \"move\") {\n\t\t\tconst index = targetInput.findIndex((item) => {\n\t\t\t\treturn typeof item === \"object\" ? `${item.id}` === id : `${item}` === id;\n\t\t\t});\n\n\t\t\tif (type === \"add\") {\n\t\t\t\tchange.item = targetInput[index];\n\t\t\t}\n\n\t\t\tchange.position = index;\n\t\t}\n\t});\n};\n/**\n * Detects changes made between 2 Item arrays.\n *\n * @param sourceInput - Original, source Item array.\n * @param targetInput - Target Item array.\n * @returns - Changes that differ the second array from the first one.\n */\nconst detectChanges = (sourceInput: Item[], targetInput: Item[]): Change[] => {\n\tconst data = createData(sourceInput, targetInput);\n\n\twhile (shouldLoop(data)) {\n\t\tif (trim(data)) {\n\t\t\tdata.index = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst { left, right } = prepareMove(data);\n\n\t\tif (left !== null || right !== null) {\n\t\t\tmove(data, left, right);\n\t\t\tdata.index = 0;\n\t\t} else {\n\t\t\tdata.index += 1;\n\t\t}\n\t}\n\n\tadd(data);\n\tremove(data);\n\tfill(data);\n\n\treturn data.changes;\n};\n\nexport { detectChanges };\n","import { Indexable } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\nimport { detectChanges } from \"../utils\";\n\ninterface MapData<\n\tS extends Indexable,\n\tC extends Indexable,\n\tI extends MappableItem = MappableItem\n> {\n\titems: Exclude<Mappable<S, C, I>, any[]>;\n\tcreateItem(item: any, node: IsotopeNode<S, C>, index: number): IsotopeNode | void;\n}\n\ntype MappableItem = string | number | { id: string | number };\n\ntype Mappable<\n\tS extends Indexable,\n\tC extends Indexable,\n\tI extends MappableItem = MappableItem\n> = I[] | keyof S | ((node: IsotopeNode<S, C>) => I[]);\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\tmapData?: MapData<S, C> | null;\n\t\t/**\n\t\t * Maps the provided data to a rendered Nodes list.\n\t\t *\n\t\t * @param items - Items to be mapped.\n\t\t * @param createItem - Rendering function to be used to render mapped items.\n\t\t * @returns - The Node.\n\t\t */\n\t\tmap<I extends MappableItem>(\n\t\t\titems: Mappable<S, C, I>,\n\t\t\tcreateItem: (item: I, node: this, index: number) => IsotopeNode | void\n\t\t): this;\n\t}\n}\n\nif (!IsotopeNode.prototype.map) {\n\t/**\n\t * Handles Nodes map update.\n\t *\n\t * @param node - The parent Node.\n\t * @param items - New items to be mapped.\n\t */\n\tconst handleMapUpdate = (node: IsotopeNode, items: MappableItem[]): void => {\n\t\tconst data = node.mapData!;\n\t\tconst changes = detectChanges(\n\t\t\t(node.linked as Array<{ id: string | number }>) || [],\n\t\t\titems\n\t\t);\n\n\t\tchanges.forEach(({ id, item, position = 0, type }, index) => {\n\t\t\tif (type === \"add\") {\n\t\t\t\tconst child = data.createItem(item, node, index);\n\n\t\t\t\tif (child) {\n\t\t\t\t\tchild.id = `${id}`;\n\t\t\t\t\tnode.link(child, position);\n\t\t\t\t\tchild.move(position);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst child = node.linked!.find((linked) => linked.id === id);\n\n\t\t\t\tif (child) {\n\t\t\t\t\tif (type === \"remove\") {\n\t\t\t\t\t\tchild.remove();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchild.move(position);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Handles the Nodes map creation.\n\t *\n\t * @param node - The parent Node.\n\t * @param items - Items to be mapped.\n\t */\n\tconst handleMapCreation = (node: IsotopeNode, items: MappableItem[]): void => {\n\t\tconst data = node.mapData!;\n\n\t\titems.forEach((item, index) => {\n\t\t\tconst child = data.createItem(item, node, index);\n\n\t\t\tif (child) {\n\t\t\t\tchild.id = `${typeof item === \"object\" ? item.id : item}`;\n\t\t\t\tnode.link(child);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Processes the provided Node's map child tree.\n\t *\n\t * @param node - Node to be processed.\n\t */\n\tconst processMap = (node: IsotopeNode): void => {\n\t\tif (node.mapData) {\n\t\t\tconst data = node.mapData;\n\t\t\tconst items: MappableItem[] & { isotopeMapped?: boolean } =\n\t\t\t\ttypeof data.items === \"function\" ? data.items(node) : node.getState(data.items);\n\n\t\t\tif (!items.isotopeMapped) {\n\t\t\t\tif (items.length === 0) {\n\t\t\t\t\tnode.linked = [];\n\t\t\t\t\tnode.element.textContent = \"\";\n\t\t\t\t} else if (node.linked) {\n\t\t\t\t\thandleMapUpdate(node, items);\n\t\t\t\t} else {\n\t\t\t\t\thandleMapCreation(node, items);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\titems.isotopeMapped = true;\n\t\t}\n\t};\n\n\tIsotopeNode.prototype.onClean.push((node) => {\n\t\tif (node.mapData) {\n\t\t\tnode.mapData = null;\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.mapData) {\n\t\t\tprocessMap(node);\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\tmap(\n\t\t\tthis: IsotopeNode,\n\t\t\titems: Mappable<any, any>,\n\t\t\tcreateItem: (item: any, node: IsotopeNode, index: number) => IsotopeNode | void\n\t\t): IsotopeNode {\n\t\t\tthis.clean();\n\n\t\t\tif (Array.isArray(items)) {\n\t\t\t\titems.forEach((item, index) => {\n\t\t\t\t\tcreateItem(item, this, index);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.mapData = {\n\t\t\t\t\tcreateItem,\n\t\t\t\t\titems\n\t\t\t\t};\n\t\t\t\tprocessMap(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","import { Indexable } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\n\ntype TextData<S extends Indexable, C extends Indexable> = (\n\tnode: IsotopeNode<S, C>\n) => string;\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\ttextData?: TextData<S, C> | null;\n\t\t/**\n\t\t * Sets the Node's element text.\n\t\t *\n\t\t * @param text - Text to be set.\n\t\t * @returns - The Node.\n\t\t */\n\t\ttext(text: TextData<S, C> | string): this;\n\t}\n}\n\nif (!IsotopeNode.prototype.text) {\n\t/**\n\t * Processes the provided Node's text child tree.\n\t *\n\t * @param node - Node to be processed.\n\t */\n\tconst processText = (node: IsotopeNode): void => {\n\t\tif (node.textData) {\n\t\t\tconst data = node.textData(node);\n\n\t\t\tif (data !== node.element.textContent) {\n\t\t\t\tnode.element.textContent = data;\n\t\t\t}\n\t\t}\n\t};\n\n\tIsotopeNode.prototype.onClean.push((node) => {\n\t\tif (node.textData) {\n\t\t\tnode.textData = null;\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.textData) {\n\t\t\tprocessText(node);\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\ttext(this: IsotopeNode, text: TextData<any, any> | string): IsotopeNode {\n\t\t\tthis.clean();\n\n\t\t\tif (typeof text === \"function\") {\n\t\t\t\tthis.textData = text;\n\t\t\t\tprocessText(this);\n\t\t\t} else {\n\t\t\t\tthis.element.textContent = text;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","import { Directive, IsotopeNode, IsotopeNodeConfig } from \"../../node\";\nimport { Indexable } from \"../../declarations\";\n\ntype Child = <S extends Indexable = any, C extends Indexable = any>(\n\tconfig?:\n\t\t| IsotopeNodeConfig<S, C>\n\t\t| string\n\t\t| Directive<S, C, void>\n\t\t| Array<Directive<S, C, void>>\n) => IsotopeNode<S, C>;\n\n/**\n * Registers new Node child function.\n *\n * @param name - Name for the child.\n */\nconst registerChild = (name: string): void => {\n\t/** @private */\n\tif (!IsotopeNode.prototype[name as keyof typeof IsotopeNode.prototype]) {\n\t\tIsotopeNode.prototype[name as keyof typeof IsotopeNode.prototype] = function (\n\t\t\tthis: IsotopeNode,\n\t\t\tconfig?: IsotopeNodeConfig<any, any> | string\n\t\t) {\n\t\t\treturn this.child(name, config);\n\t\t};\n\t}\n};\n\nexport { Child, registerChild };\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tblockquote: Child;\n\t\tdd: Child;\n\t\tdiv: Child;\n\t\tdl: Child;\n\t\tdt: Child;\n\t\tfigcaption: Child;\n\t\tfigure: Child;\n\t\thr: Child;\n\t\tli: Child;\n\t\tmain: Child;\n\t\tol: Child;\n\t\tp: Child;\n\t\tpre: Child;\n\t\tul: Child;\n\t}\n}\n\nconst nodes = [\n\t\"blockquote\",\n\t\"dd\",\n\t\"div\",\n\t\"dl\",\n\t\"dt\",\n\t\"figcaption\",\n\t\"figure\",\n\t\"hr\",\n\t\"li\",\n\t\"main\",\n\t\"ol\",\n\t\"p\",\n\t\"pre\",\n\t\"ul\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tembed: Child;\n\t\tiframe: Child;\n\t\tobject: Child;\n\t\tparam: Child;\n\t\tpicture: Child;\n\t\tsource: Child;\n\t}\n}\n\nconst nodes = [\"embed\", \"iframe\", \"object\", \"param\", \"picture\", \"source\"];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tbutton: Child;\n\t\tdatalist: Child;\n\t\tfieldset: Child;\n\t\tform: Child;\n\t\tinput: Child;\n\t\tlabel: Child;\n\t\tlegend: Child;\n\t\tmeter: Child;\n\t\toptgroup: Child;\n\t\toption: Child;\n\t\toutput: Child;\n\t\tprogress: Child;\n\t\tselect: Child;\n\t\ttextarea: Child;\n\t}\n}\n\nconst nodes = [\n\t\"button\",\n\t\"datalist\",\n\t\"fieldset\",\n\t\"form\",\n\t\"input\",\n\t\"label\",\n\t\"legend\",\n\t\"meter\",\n\t\"optgroup\",\n\t\"option\",\n\t\"output\",\n\t\"progress\",\n\t\"select\",\n\t\"textarea\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tdetails: Child;\n\t\tdialog: Child;\n\t\tmenu: Child;\n\t\tsummary: Child;\n\t\tcanvas: Child;\n\t\tscript: Child;\n\t\tnoscript: Child;\n\t\tslot: Child;\n\t\ttemplate: Child;\n\t}\n}\n\nconst nodes = [\n\t\"details\",\n\t\"dialog\",\n\t\"menu\",\n\t\"summary\",\n\t\"canvas\",\n\t\"script\",\n\t\"noscript\",\n\t\"slot\",\n\t\"template\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tarea: Child;\n\t\taudio: Child;\n\t\timg: Child;\n\t\ttrack: Child;\n\t\tvideo: Child;\n\t}\n}\n\nconst nodes = [\"area\", \"audio\", \"img\", \"track\", \"video\"];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\taddress: Child;\n\t\tarticle: Child;\n\t\taside: Child;\n\t\tfooter: Child;\n\t\theader: Child;\n\t\th1: Child;\n\t\th2: Child;\n\t\th3: Child;\n\t\th4: Child;\n\t\th5: Child;\n\t\th6: Child;\n\t\thgroup: Child;\n\t\tmain: Child;\n\t\tnav: Child;\n\t\tsection: Child;\n\t}\n}\n\nconst nodes = [\n\t\"address\",\n\t\"article\",\n\t\"aside\",\n\t\"footer\",\n\t\"header\",\n\t\"h1\",\n\t\"h2\",\n\t\"h3\",\n\t\"h4\",\n\t\"h5\",\n\t\"h6\",\n\t\"hgroup\",\n\t\"main\",\n\t\"nav\",\n\t\"section\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tcaption: Child;\n\t\tcol: Child;\n\t\tcolgroup: Child;\n\t\ttable: Child;\n\t\ttbody: Child;\n\t\ttd: Child;\n\t\ttfoot: Child;\n\t\tth: Child;\n\t\tthead: Child;\n\t\ttr: Child;\n\t}\n}\n\nconst nodes = [\n\t\"caption\",\n\t\"col\",\n\t\"colgroup\",\n\t\"table\",\n\t\"tbody\",\n\t\"td\",\n\t\"tfoot\",\n\t\"th\",\n\t\"thead\",\n\t\"tr\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tdel: Child;\n\t\tins: Child;\n\t\ta: Child;\n\t\tabbr: Child;\n\t\tb: Child;\n\t\tbdi: Child;\n\t\tbdo: Child;\n\t\tbr: Child;\n\t\tcite: Child;\n\t\tcode: Child;\n\t\tdata: Child;\n\t\tdfn: Child;\n\t\tem: Child;\n\t\ti: Child;\n\t\tkbd: Child;\n\t\tmark: Child;\n\t\tq: Child;\n\t\trb: Child;\n\t\trp: Child;\n\t\trt: Child;\n\t\trtc: Child;\n\t\truby: Child;\n\t\ts: Child;\n\t\tsamp: Child;\n\t\tsmall: Child;\n\t\tspan: Child;\n\t\tstrong: Child;\n\t\tsub: Child;\n\t\tsup: Child;\n\t\ttime: Child;\n\t\tu: Child;\n\t\tvar: Child;\n\t\twbr: Child;\n\t}\n}\n\nconst nodes = [\n\t\"del\",\n\t\"ins\",\n\t\"a\",\n\t\"abbr\",\n\t\"b\",\n\t\"bdi\",\n\t\"bdo\",\n\t\"br\",\n\t\"cite\",\n\t\"code\",\n\t\"data\",\n\t\"dfn\",\n\t\"em\",\n\t\"i\",\n\t\"kbd\",\n\t\"mark\",\n\t\"q\",\n\t\"rb\",\n\t\"rp\",\n\t\"rt\",\n\t\"rtc\",\n\t\"ruby\",\n\t\"s\",\n\t\"samp\",\n\t\"small\",\n\t\"span\",\n\t\"strong\",\n\t\"sub\",\n\t\"sup\",\n\t\"time\",\n\t\"u\",\n\t\"var\",\n\t\"wbr\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { IsotopeNode } from \"./node\";\n\ninterface IsotopeViewConfig {\n\tattach?: boolean;\n\tclean?: boolean;\n}\n\n/**\n * Creates a DOM View.\n *\n * @param element - Element to append to.\n * @param config - DOM View config.\n * @returns - The created top-level Node.\n */\nconst createDOMView = (element: Element, config?: IsotopeViewConfig): IsotopeNode => {\n\tif (IsotopeNode.prototype.customDOM) {\n\t\tIsotopeNode.prototype.customDOM = null;\n\t}\n\n\tif (!config || (config && config.clean && !config.attach)) {\n\t\telement.textContent = \"\";\n\t}\n\n\treturn new IsotopeNode(element, config);\n};\n\nexport { createDOMView };\n"],"names":["IsotopeNode","[object Object]","element","config","this","getElement","textContent","attach","childIndex","autoLink","state","context","onCreate","forEach","callback","process","directives","Array","isArray","directive","value","tag","shouldAttach","isConfigDirective","index","attachTarget","children","node","appendChild","passContext","link","$","linked","onClean","event","data","listenedEvents","includes","dispatchEvent","Object","assign","customDOM","createEvent","Event","key","position","nodeLinkup","linkup","splice","indexOf","push","upperLinked","referenceNode","insertBefore","handler","options","removeEventListener","addEventListener","parentElement","removeChild","emit","namespace","createElement","document","createElementNS","onProcess","prototype","setAttribs","attribs","attrib","getAttribute","setAttribute","removeAttribute","entries","setAttrib","setClasses","classes","join","filter","apply","map","name","className","classList","add","contains","remove","addClass","removeClass","setStyles","styles","property","style","setStyle","if","processConditional","conditionalData","condition","processedCondition","Boolean","getState","previous","onTrue","onFalse","clean","shouldLoop","source","target","length","trim","sourceStart","sourceEnd","targetStart","targetEnd","trimmed","shift","pop","prepareMove","moveRight","left","right","move","changes","itemToLeft","itemToRight","id","type","handleMapUpdate","items","mapData","sourceInput","targetInput","item","createData","change","findIndex","fill","detectChanges","child","createItem","find","handleMapCreation","processMap","isotopeMapped","text","processText","textData","registerChild"],"mappings":"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AclE,KCKD,CACb,SACA,WACA,WACA,OACA,QACA,QACA,SACA,QACA,WACA,SACA,SACA,WACA,SACA,YAGKpE,QAASoE,IACdkE,EAAclE,KCvBD,CACb,UACA,SACA,OACA,UACA,SACA,SACA,WACA,OACA,YAGKpE,QAASoE,IACdkE,EAAclE,KCjBD,CAAC,OAAQ,QAAS,MAAO,QAAS,SAE1CpE,QAASoE,IACdkE,EAAclE,KCOD,CACb,UACA,UACA,QACA,SACA,SACA,KACA,KACA,KACA,KACA,KACA,KACA,SACA,OACA,MACA,WAGKpE,QAASoE,IACdkE,EAAclE,KCxBD,CACb,UACA,MACA,WACA,QACA,QACA,KACA,QACA,KACA,QACA,MAGKpE,QAASoE,IACdkE,EAAclE,KCSD,CACb,MACA,MACA,IACA,OACA,IACA,MACA,MACA,KACA,OACA,OACA,OACA,MACA,KACA,IACA,MACA,OACA,IACA,KACA,KACA,KACA,MACA,OACA,IACA,OACA,QACA,OACA,SACA,MACA,MACA,OACA,IACA,MACA,OAGKpE,QAASoE,IACdkE,EAAclE,qCC/DO,EAAC/E,EAAkBC,KACpCH,EAAYkE,UAAUzB,YACzBzC,EAAYkE,UAAUzB,UAAY,QAG9BtC,GAAWA,GAAUA,EAAOqG,QAAUrG,EAAOI,UACjDL,EAAQI,YAAc,IAGhB,IAAIN,EAAYE,EAASC"}