{"version":3,"file":"isotope.min.js","sources":["../src/node.ts","../src/views/string/element.ts","../src/nodes/conditional.ts","../src/configurators/attribs.ts","../src/configurators/classes.ts","../src/configurators/styles.ts","../src/utils.ts","../src/nodes/map.ts","../src/nodes/text.ts","../src/nodes/html/register.ts","../src/nodes/html/content.ts","../src/nodes/html/embed.ts","../src/nodes/html/form.ts","../src/nodes/html/interactive.ts","../src/nodes/html/media.ts","../src/nodes/html/section.ts","../src/nodes/html/table.ts","../src/nodes/html/text.ts","../src/views/dom.ts","../src/views/string/string.ts"],"sourcesContent":["import { CustomDOM, CustomElement, Indexable } from \"./declarations\";\n\ninterface IsotopeNodeConfig<S extends Indexable, C extends Indexable> {\n\tnamespace?: string;\n\tautoLink?: boolean;\n\tattach?: boolean;\n\tcontext?: C;\n\tstate?: S;\n}\n\ninterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\tonCreate: Array<(node: this, config: IsotopeNodeConfig<S, C>) => void>;\n\tonProcess: Array<(node: this) => void>;\n\tonClean: Array<(node: this) => void>;\n\tcustomDOM?: CustomDOM | null;\n}\n\ntype Directive<S extends Indexable, C extends Indexable, R extends void | any> = (\n\tnode: IsotopeNode<S, C>\n) => R;\n\n/**\n * Class representing a Node.\n */\nclass IsotopeNode<S extends Indexable = any, C extends Indexable = any>\n\timplements IsotopeNode<S, C> {\n\tpublic state?: S;\n\n\tpublic context?: C;\n\n\tpublic id?: string;\n\n\tpublic linked?: IsotopeNode[] | null;\n\n\tpublic element: CustomElement;\n\n\tprotected linkup?: IsotopeNode | null;\n\n\tprotected childIndex?: number;\n\n\tprotected autoLink?: boolean;\n\n\t/**\n\t * Creates a new Node.\n\t *\n\t * @param element -  The Node's HTML element or tag.\n\t * @param config - The Node's configuration.\n\t */\n\tpublic constructor(\n\t\telement: string | CustomElement | Element,\n\t\tconfig?:\n\t\t\t| IsotopeNodeConfig<S, C>\n\t\t\t| string\n\t\t\t| Directive<S, C, void>\n\t\t\t| Array<Directive<S, C, void>>\n\t) {\n\t\tthis.element = this.getElement(element, config);\n\n\t\tif (typeof config === \"string\") {\n\t\t\tthis.element.textContent = config;\n\t\t} else if (typeof config === \"object\" && !Array.isArray(config)) {\n\t\t\tif (config.attach) {\n\t\t\t\tthis.childIndex = 0;\n\t\t\t}\n\n\t\t\tif (config.autoLink) {\n\t\t\t\tthis.autoLink = config.autoLink;\n\t\t\t}\n\n\t\t\tif (config.state) {\n\t\t\t\tthis.state = config.state;\n\t\t\t}\n\n\t\t\tif (config.context) {\n\t\t\t\tthis.context = config.context;\n\t\t\t}\n\n\t\t\tthis.onCreate.forEach((callback) => {\n\t\t\t\tcallback(this, config);\n\t\t\t});\n\t\t} else if (config) {\n\t\t\tthis.$(config);\n\t\t}\n\n\t\tthis.process();\n\t}\n\n\t/**\n\t * Executes the provided directive(s).\n\t *\n\t * @param directives - Directive(s) to be executed.\n\t * @returns - The Node or the return value of the directive.\n\t */\n\tpublic $<R extends void | any>(\n\t\tdirectives: Directive<S, C, R> | Array<Directive<S, C, void>>\n\t): R extends void ? this : R {\n\t\tif (Array.isArray(directives)) {\n\t\t\tdirectives.forEach((directive) => {\n\t\t\t\tdirective(this);\n\t\t\t});\n\t\t} else {\n\t\t\tconst value = directives(this);\n\n\t\t\tif (typeof value !== \"undefined\") {\n\t\t\t\treturn value as R extends void ? this : R;\n\t\t\t}\n\t\t}\n\n\t\treturn this as R extends void ? this : R;\n\t}\n\n\t/**\n\t * Adds a child Node to the Node.\n\t *\n\t * @param tag - Child Node's HTML tag.\n\t * @param config - Child Node's configuration.\n\t * @returns - The created child Node.\n\t */\n\tpublic child<S2 extends Indexable = Indexable, C2 extends Indexable = Indexable>(\n\t\ttag: string,\n\t\tconfig?:\n\t\t\t| IsotopeNodeConfig<S2, Partial<C> & C2>\n\t\t\t| string\n\t\t\t| Directive<S2, Partial<C> & C2, void>\n\t\t\t| Array<Directive<S2, Partial<C> & C2, void>>\n\t): IsotopeNode<S2, Partial<C> & C2> {\n\t\tconst shouldAttach = typeof this.childIndex !== \"undefined\";\n\n\t\tlet element: CustomElement | Element | string = tag;\n\n\t\tif (shouldAttach) {\n\t\t\tconst attachTarget = this.element.children[this.childIndex || 0];\n\n\t\t\tif (attachTarget) {\n\t\t\t\telement = attachTarget;\n\t\t\t\tthis.childIndex = (this.childIndex || 0) + 1;\n\t\t\t}\n\t\t}\n\n\t\tconst node = new IsotopeNode<S2, Partial<C> & C2>(element, config);\n\n\t\tthis.element.appendChild(node.element);\n\n\t\tif (shouldAttach && !node.childIndex) {\n\t\t\tnode.childIndex = 0;\n\t\t}\n\n\t\tif (this.context) {\n\t\t\tif (node.context) {\n\t\t\t\tnode.context = Object.assign(node.context, this.context);\n\t\t\t} else {\n\t\t\t\tnode.context = this.context as C & C2;\n\t\t\t}\n\t\t}\n\n\t\tif (this.autoLink) {\n\t\t\tthis.link(node);\n\t\t}\n\n\t\treturn node;\n\t}\n\n\t/**\n\t * Cleans the Node's child tree.\n\t *\n\t * @returns - IsotopeNode.\n\t */\n\tpublic clean(): this {\n\t\tif (this.linked) {\n\t\t\tthis.linked = null;\n\t\t}\n\n\t\tthis.onClean.forEach((callback) => {\n\t\t\tcallback(this);\n\t\t});\n\t\tthis.element.textContent = \"\";\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Emits the specified event.\n\t *\n\t * @param event - Event to be emitted.\n\t * @param data - Data to be passed to the listening function.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic emit(event: string, data: object = {}): this {\n\t\tthis.element.dispatchEvent(\n\t\t\tObject.assign(\n\t\t\t\tthis.customDOM ? this.customDOM.createEvent(event) : new Event(event),\n\t\t\t\t{ node: this },\n\t\t\t\tdata\n\t\t\t)\n\t\t);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Retrieves the data from the Node's context.\n\t *\n\t * @param key - Data key to be retrieved.\n\t * @returns - The retrieved data.\n\t */\n\tpublic getContext<K extends keyof C>(key: K): C[K] | null {\n\t\treturn this.context ? this.context[key] : null;\n\t}\n\n\t/**\n\t * Retrieves the data from the Node's state.\n\t *\n\t * @param key - Data key to be retrieved.\n\t * @returns - The retrieved data.\n\t */\n\tpublic getState<K extends keyof S>(key: K): S[K] | null {\n\t\treturn this.state ? this.state[key] : null;\n\t}\n\n\t/**\n\t * Links the provided Node.\n\t *\n\t * @param node - Node to be linked.\n\t * @param position - Position to place Node at in the linked array.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic link(node: IsotopeNode, position?: number): this {\n\t\tconst nodeLinkup = node.linkup;\n\n\t\tif (nodeLinkup !== this) {\n\t\t\tif (nodeLinkup && nodeLinkup.linked) {\n\t\t\t\tnodeLinkup.linked.splice(nodeLinkup.linked.indexOf(node), 1);\n\t\t\t}\n\n\t\t\tif (!this.linked) {\n\t\t\t\tthis.linked = [];\n\t\t\t}\n\n\t\t\tif (position) {\n\t\t\t\tthis.linked.splice(position, 0, node);\n\t\t\t} else {\n\t\t\t\tthis.linked.push(node);\n\t\t\t}\n\n\t\t\tnode.linkup = this;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Moves the linked Node to the provided position.\n\t *\n\t * @param position - Position index to move the Node to.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic move(position: number): this {\n\t\tconst { linkup } = this;\n\n\t\tif (linkup && linkup.linked) {\n\t\t\tconst upperLinked = linkup.linked;\n\t\t\tconst [node] = upperLinked.splice(upperLinked.indexOf(this as any), 1);\n\n\t\t\tupperLinked.splice(position, 0, node);\n\n\t\t\tconst referenceNode = upperLinked[position + 1];\n\n\t\t\tlinkup.element.insertBefore(\n\t\t\t\tthis.element,\n\t\t\t\treferenceNode ? referenceNode.element : null\n\t\t\t);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Disables the specified event listener.\n\t *\n\t * @param event - Event to disable the listener for.\n\t * @param handler - Event handler to be disabled.\n\t * @param options - Event listening options.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic off<K extends keyof HTMLElementEventMap>(\n\t\tevent: K | string,\n\t\thandler: (ev: HTMLElementEventMap[K]) => any,\n\t\toptions?: boolean | EventListenerOptions\n\t): this;\n\n\t/** @private */\n\tpublic off(\n\t\tevent: string,\n\t\thandler: EventListenerOrEventListenerObject,\n\t\toptions?: boolean | EventListenerOptions\n\t): this {\n\t\tthis.element.removeEventListener(event, handler, options);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Setups an event listener for the specified event.\n\t *\n\t * @param event - Event to be listened to.\n\t * @param handler - Event handling function.\n\t * @param options - Event listening options.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic on<K extends keyof HTMLElementEventMap>(\n\t\tevent: K | string,\n\t\thandler: (data: HTMLElementEventMap[K]) => void,\n\t\toptions?: boolean | AddEventListenerOptions\n\t): this;\n\n\t/** @private */\n\tpublic on(\n\t\tevent: string,\n\t\thandler: EventListenerOrEventListenerObject,\n\t\toptions?: boolean | AddEventListenerOptions\n\t): this {\n\t\tthis.element.addEventListener(event, handler, options);\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Removes the Node.\n\t *\n\t * @returns - IsotopeNode.\n\t */\n\tpublic remove(): this {\n\t\tconst { linkup } = this;\n\n\t\tif (linkup && linkup.linked) {\n\t\t\tlinkup.linked.splice(linkup.linked.indexOf(this as any), 1);\n\t\t}\n\n\t\tif (this.linked) {\n\t\t\tthis.linked = null;\n\t\t}\n\n\t\tif (this.element.parentElement) {\n\t\t\tthis.element.parentElement.removeChild(this.element);\n\t\t}\n\n\t\tthis.emit(\"node-removed\");\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the Node's state.\n\t *\n\t * @param state - State object to be set.\n\t * @returns - IsotopeNode.\n\t */\n\tpublic setState(state: Partial<S>): this {\n\t\tif (this.state) {\n\t\t\tObject.assign(this.state, state);\n\t\t\tthis.emit(\"state-changed\");\n\t\t\tthis.process();\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stringifies Node's element.\n\t *\n\t * @returns - Stringified Node's element.\n\t */\n\tpublic toString(): string {\n\t\treturn `${this.element}`;\n\t}\n\n\t/**\n\t * Retrieves the proper element from Node's configuration.\n\t *\n\t * @param element -  The Node's element or tag.\n\t * @param config - The Node's configuration.\n\t * @returns - Retrieved element.\n\t */\n\tprotected getElement(\n\t\telement: string | CustomElement | Element,\n\t\tconfig?:\n\t\t\t| IsotopeNodeConfig<S, C>\n\t\t\t| string\n\t\t\t| Directive<S, C, void>\n\t\t\t| Array<Directive<S, C, void>>\n\t): CustomElement {\n\t\tif (typeof element === \"string\") {\n\t\t\tif (typeof config === \"object\" && !Array.isArray(config) && config.namespace) {\n\t\t\t\tif (this.customDOM) {\n\t\t\t\t\treturn this.customDOM.createElement(element, config.namespace);\n\t\t\t\t}\n\n\t\t\t\treturn (document.createElementNS(\n\t\t\t\t\tconfig.namespace,\n\t\t\t\t\telement\n\t\t\t\t) as any) as CustomElement;\n\t\t\t} else if (this.customDOM) {\n\t\t\t\treturn this.customDOM.createElement(element);\n\t\t\t}\n\n\t\t\treturn (document.createElement(element) as any) as CustomElement;\n\t\t}\n\n\t\treturn element as CustomElement;\n\t}\n\n\t/**\n\t * Processes and renders the Node.\n\t */\n\tprotected process(): void {\n\t\tthis.emit(\"node-updated\");\n\t\tthis.onProcess.forEach((callback) => {\n\t\t\tcallback(this);\n\t\t});\n\n\t\tif (this.linked) {\n\t\t\tthis.linked.forEach((linked) => {\n\t\t\t\tlinked.process();\n\t\t\t});\n\t\t}\n\t}\n}\n\nObject.assign(IsotopeNode.prototype, {\n\tonClean: [],\n\tonCreate: [],\n\tonProcess: []\n});\n\nexport { Directive, IsotopeNode, IsotopeNodeConfig };\n","/* eslint-disable @typescript-eslint/no-empty-function */\nimport { CustomElement, Indexable } from \"../../declarations\";\nimport { Properties } from \"csstype\";\n\n/**\n * Class implementing Isotope CustomElement API, allowing for easy server-side stringification.\n */\nclass StringElement implements CustomElement {\n\tpublic children: StringElement[] = [];\n\n\tpublic classList = {\n\t\tadd: (...tokens: string[]): void => {\n\t\t\tthis.classes.push(...tokens);\n\t\t},\n\t\tcontains: (token: string): boolean => {\n\t\t\treturn this.classes.includes(token);\n\t\t},\n\t\tremove: (...tokens: string[]): void => {\n\t\t\ttokens.forEach((token) => {\n\t\t\t\tthis.classes.splice(this.classes.indexOf(token), 1);\n\t\t\t});\n\t\t}\n\t};\n\n\tpublic parentElement: StringElement | null = null;\n\n\tpublic style: Properties<string> = {};\n\n\tpublic tagName: string;\n\n\tprotected attributes: { [name: string]: string | null } = {};\n\n\tprotected classes: string[] = [];\n\n\tprivate $textContent: string | null = \"\";\n\n\tprivate events: Indexable<EventListenerOrEventListenerObject[]> = {};\n\n\t/**\n\t * Creates a new ServerElement instance.\n\t *\n\t * @param tag - Tag to be used for the element.\n\t */\n\tpublic constructor(tag: string) {\n\t\tthis.tagName = tag;\n\t}\n\n\t/** @private */\n\tpublic addEventListener(\n\t\ttype: string,\n\t\tlistener: EventListenerOrEventListenerObject\n\t): void {\n\t\t(this.events[type] || (this.events[type] = [])).push(listener);\n\t}\n\n\t/** @private */\n\tpublic appendChild(newChild: StringElement): StringElement {\n\t\tthis.children.push(newChild);\n\t\tnewChild.parentElement = this;\n\n\t\treturn newChild;\n\t}\n\n\t/** @private */\n\tpublic dispatchEvent(event: CustomEvent): boolean {\n\t\t(this.events[event.type] || []).slice().forEach((handler) => {\n\t\t\tif (typeof handler === \"function\") {\n\t\t\t\thandler(event);\n\t\t\t} else {\n\t\t\t\thandler.handleEvent(event);\n\t\t\t}\n\t\t});\n\n\t\treturn true;\n\t}\n\n\t/** @private */\n\tpublic getAttribute(qualifiedName: string): string | null {\n\t\treturn this.attributes[qualifiedName];\n\t}\n\n\t/** @private */\n\tpublic insertBefore(\n\t\tnewChild: StringElement,\n\t\trefChild: StringElement | null\n\t): StringElement {\n\t\tnewChild.parentElement = this;\n\n\t\tif (refChild) {\n\t\t\tconst index = this.children.indexOf(refChild);\n\n\t\t\tif (index >= 0) {\n\t\t\t\tthis.children.splice(index + 1, 0, newChild);\n\n\t\t\t\treturn newChild;\n\t\t\t}\n\t\t}\n\n\t\tthis.children.push(newChild);\n\n\t\treturn newChild;\n\t}\n\n\t/** @private */\n\tpublic removeAttribute(qualifiedName: string): void {\n\t\tthis.attributes[qualifiedName] = null;\n\t}\n\n\t/** @private */\n\tpublic removeChild(oldChild: StringElement): StringElement {\n\t\toldChild.parentElement = null;\n\t\tthis.children.splice(this.children.indexOf(oldChild), 1);\n\n\t\treturn oldChild;\n\t}\n\n\t/** @private */\n\tpublic removeEventListener(\n\t\ttype: string,\n\t\tlistener: EventListenerOrEventListenerObject\n\t): void {\n\t\tif (this.events[type]) {\n\t\t\tthis.events[type].splice(this.events[type].indexOf(listener) >>> 0, 1);\n\t\t}\n\t}\n\n\t/** @private */\n\tpublic setAttribute(qualifiedName: string, value: string): void {\n\t\tthis.attributes[qualifiedName] = value;\n\t}\n\n\t/** @private */\n\tpublic set textContent(textContent: string | null) {\n\t\tthis.children = [];\n\t\tthis.$textContent = textContent || \"\";\n\t}\n\n\t/** @private */\n\tpublic get textContent(): string | null {\n\t\treturn this.$textContent;\n\t}\n\n\t/**\n\t * Stringifies the ServerElement.\n\t *\n\t * @returns - Stringified ServerElement.\n\t */\n\tpublic toString(): string {\n\t\tconst tag = this.tagName;\n\t\tconst content =\n\t\t\tthis.textContent ||\n\t\t\tthis.children\n\t\t\t\t.map((child) => {\n\t\t\t\t\treturn `${child}`;\n\t\t\t\t})\n\t\t\t\t.join(\"\");\n\t\tconst classes = this.classes.join(\" \");\n\t\tconst styles = Object.entries(this.style)\n\t\t\t.map(([property, value]) => {\n\t\t\t\tconst propertyKebabCase = property.replace(\n\t\t\t\t\t/[A-Z]/g,\n\t\t\t\t\t(match) => `-${match.toLowerCase()}`\n\t\t\t\t);\n\n\t\t\t\treturn `${propertyKebabCase}:${value}`;\n\t\t\t})\n\t\t\t.join(\";\");\n\t\tconst attributes = Object.entries(this.attributes)\n\t\t\t.map(([name, value]) => {\n\t\t\t\treturn `${name}=\"${value}\"`;\n\t\t\t})\n\t\t\t.join(\" \");\n\n\t\treturn `<${tag}${classes ? ` class=\"${classes}\"` : \"\"}${\n\t\t\tstyles ? `style=\"${styles}\"` : \"\"\n\t\t}${attributes}>${content}</${tag}>`;\n\t}\n}\n\nexport { StringElement };\n","import { Indexable } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\n\ninterface ConditionalData<S extends Indexable, C extends Indexable> {\n\tprevious?: boolean;\n\tcondition: keyof S | ((node: IsotopeNode<S, C>) => boolean);\n\tonTrue(node: IsotopeNode<S, C>): IsotopeNode | void;\n\tonFalse?(node: IsotopeNode<S, C>): IsotopeNode | void;\n}\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\tconditionalData?: ConditionalData<S, C> | null;\n\t\t/**\n\t\t * Conditionally renders the provided nodes.\n\t\t *\n\t\t * @param condition - Condition to be checked.\n\t\t * @param onTrue - Rendering function to be executed when condition is truthy.\n\t\t * @param onFalse - Rendering function to be executed when condition is falsy.\n\t\t * @returns - The Node.\n\t\t */\n\t\tif(\n\t\t\tcondition: boolean | keyof S | ((node: this) => boolean),\n\t\t\tonTrue: (node: this) => IsotopeNode | void,\n\t\t\tonFalse?: (node: this) => IsotopeNode | void\n\t\t): this;\n\t}\n}\n\nif (!IsotopeNode.prototype.if) {\n\t/**\n\t * Processes the provided Node's conditional child tree.\n\t *\n\t * @param node - Node to be processed.\n\t */\n\tconst processConditional = (node: IsotopeNode): void => {\n\t\tif (node.conditionalData) {\n\t\t\tconst data = node.conditionalData;\n\t\t\tconst { condition } = data;\n\t\t\tconst processedCondition = Boolean(\n\t\t\t\ttypeof condition === \"function\" ? condition(node) : node.getState(condition)\n\t\t\t);\n\n\t\t\tif (processedCondition !== data.previous) {\n\t\t\t\tnode.element.textContent = \"\";\n\t\t\t\tnode.linked = null;\n\n\t\t\t\tif (processedCondition) {\n\t\t\t\t\tdata.onTrue(node);\n\t\t\t\t} else if (data.onFalse) {\n\t\t\t\t\tdata.onFalse(node);\n\t\t\t\t}\n\n\t\t\t\tdata.previous = processedCondition;\n\t\t\t}\n\t\t}\n\t};\n\n\tIsotopeNode.prototype.onClean.push((node) => {\n\t\tif (node.conditionalData) {\n\t\t\tnode.conditionalData = null;\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.conditionalData) {\n\t\t\tprocessConditional(node);\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\tif(\n\t\t\tthis: IsotopeNode,\n\t\t\tcondition: boolean | string | ((node: IsotopeNode) => boolean),\n\t\t\tonTrue: (node: IsotopeNode) => IsotopeNode | void,\n\t\t\tonFalse?: (node: IsotopeNode) => IsotopeNode | void\n\t\t): IsotopeNode {\n\t\t\tthis.clean();\n\n\t\t\tif (typeof condition === \"boolean\") {\n\t\t\t\tif (condition) {\n\t\t\t\t\tonTrue(this);\n\t\t\t\t} else if (onFalse) {\n\t\t\t\t\tonFalse(this);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.conditionalData = {\n\t\t\t\t\tcondition,\n\t\t\t\t\tonFalse,\n\t\t\t\t\tonTrue\n\t\t\t\t};\n\t\t\t\tprocessConditional(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","import { ConfigFunction, Indexable } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\tattribs?: ConfigFunction<S, C, Indexable<string | boolean>>;\n\t\t/**\n\t\t * Retrieves the value of the specified attribute.\n\t\t *\n\t\t * @param attrib - Attribute to be retrieved.\n\t\t * @returns - The retrieved value.\n\t\t */\n\t\tgetAttrib(attrib: string): string | boolean | null;\n\t\t/**\n\t\t * Sets the value of the specified attribute.\n\t\t *\n\t\t * @param attrib - Attribute to be set.\n\t\t * @param value - Value to assigned.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tsetAttrib(attrib: string, value?: string | boolean): this;\n\t\t/**\n\t\t * Sets multiple attributes.\n\t\t *\n\t\t * @param attribs - Object with key-value pairs of attributes and their values.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tsetAttribs(attribs: Indexable): this;\n\t}\n\tinterface IsotopeNodeConfig<S extends Indexable, C extends Indexable> {\n\t\tattribs?: Indexable | ConfigFunction<S, C, Indexable>;\n\t}\n}\n\nif (!IsotopeNode.prototype.setAttribs) {\n\tIsotopeNode.prototype.onCreate.push((node, config) => {\n\t\tif (config.attribs) {\n\t\t\tif (typeof config.attribs === \"function\") {\n\t\t\t\tnode.attribs = config.attribs as ConfigFunction<\n\t\t\t\t\tany,\n\t\t\t\t\tany,\n\t\t\t\t\tIndexable<string | boolean>\n\t\t\t\t>;\n\t\t\t} else {\n\t\t\t\tnode.setAttribs(config.attribs);\n\t\t\t}\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.attribs) {\n\t\t\tnode.setAttribs(node.attribs(node));\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\tgetAttrib(this: IsotopeNode, attrib: string): string | boolean | null {\n\t\t\tconst value = this.element.getAttribute(attrib);\n\n\t\t\treturn value === \"\" ? true : value;\n\t\t},\n\t\t/** @private */\n\t\tsetAttrib(this: IsotopeNode, attrib: string, value?: string | boolean): IsotopeNode {\n\t\t\tif (value) {\n\t\t\t\tthis.element.setAttribute(attrib, value === true ? \"\" : value);\n\t\t\t} else {\n\t\t\t\tthis.element.removeAttribute(attrib);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\n\t\t/** @private */\n\t\tsetAttribs(this: IsotopeNode, attribs: Indexable): IsotopeNode {\n\t\t\tObject.entries(attribs).forEach(([attrib, value]) => {\n\t\t\t\tthis.setAttrib(attrib, value);\n\t\t\t});\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","import { ConfigFunction, Indexable } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\tclasses?: ConfigFunction<S, C, string[] | Indexable<boolean>>;\n\t\t/**\n\t\t * Applies the specified CSS class name to the Node's element.\n\t\t *\n\t\t * @param className - CSS class name to be applied.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\taddClass(className: string): this;\n\t\t/**\n\t\t * Checks if the Node's element contains the specified CSS class name.\n\t\t *\n\t\t * @param className - CSS class name to be checked.\n\t\t * @returns - If the Node's element contains the specified CSS class name.\n\t\t */\n\t\thasClass(className: string): boolean;\n\t\t/**\n\t\t * Removes the specified CSS class name from the Node's element.\n\t\t *\n\t\t * @param className - CSS class name to be removed.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tremoveClass(className: string): this;\n\t\t/**\n\t\t * Sets multiple CSS class names.\n\t\t *\n\t\t * @param classes - Object or array with CSS class name to be set.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tsetClasses(classes: string[] | Indexable<boolean>): this;\n\t}\n\tinterface IsotopeNodeConfig<S extends Indexable, C extends Indexable> {\n\t\tclasses?:\n\t\t\t| string[]\n\t\t\t| Indexable<boolean>\n\t\t\t| ConfigFunction<S, C, Indexable<boolean> | string[]>;\n\t}\n}\n\nif (!IsotopeNode.prototype.setClasses) {\n\tIsotopeNode.prototype.onCreate.push((node, config) => {\n\t\tif (config.classes) {\n\t\t\tif (typeof config.classes === \"function\") {\n\t\t\t\tnode.classes = config.classes;\n\t\t\t} else {\n\t\t\t\tnode.setClasses(config.classes);\n\t\t\t}\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.classes) {\n\t\t\tnode.setClasses(node.classes(node));\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\taddClass(this: IsotopeNode, className: string): IsotopeNode {\n\t\t\tthis.element.classList.add(className);\n\n\t\t\treturn this;\n\t\t},\n\t\t/** @private */\n\t\thasClass(this: IsotopeNode, className: string): boolean {\n\t\t\treturn this.element.classList.contains(className);\n\t\t},\n\t\t/** @private */\n\t\tremoveClass(this: IsotopeNode, className: string): IsotopeNode {\n\t\t\tthis.element.classList.remove(className);\n\n\t\t\treturn this;\n\t\t},\n\t\t/** @private */\n\t\tsetClasses(this: IsotopeNode, classes: string[] | Indexable<boolean>): IsotopeNode {\n\t\t\tif (Array.isArray(classes)) {\n\t\t\t\tclasses.forEach((className) => this.addClass(className));\n\t\t\t} else {\n\t\t\t\tObject.entries(classes).forEach(([className, value]) => {\n\t\t\t\t\tif (value) {\n\t\t\t\t\t\tthis.addClass(className);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.removeClass(className);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","import { ConfigFunction, Indexable, StyleProperties } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\tstyles?: ConfigFunction<S, C, StyleProperties>;\n\t\t/**\n\t\t * Retrieves the value of the specified style property.\n\t\t *\n\t\t * @param property - Property to be retrieved.\n\t\t * @returns - The retrieved value.\n\t\t */\n\t\tgetStyle<P extends keyof StyleProperties>(\n\t\t\tproperty: P\n\t\t): StyleProperties[P] | undefined;\n\t\t/**\n\t\t * Sets the specified style property.\n\t\t *\n\t\t * @param property - Property to be set.\n\t\t * @param value - Value to be assigned.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tsetStyle<P extends keyof StyleProperties>(\n\t\t\tproperty: P,\n\t\t\tvalue: StyleProperties[P]\n\t\t): this;\n\t\t/**\n\t\t * Sets multiple style properties.\n\t\t *\n\t\t * @param styles - Object with style properties to be set.\n\t\t * @returns - IsotopeNode.\n\t\t */\n\t\tsetStyles(this: IsotopeNode, styles: StyleProperties): this;\n\t}\n\tinterface IsotopeNodeConfig<S extends Indexable, C extends Indexable> {\n\t\tstyles?: StyleProperties | ConfigFunction<S, C, StyleProperties>;\n\t}\n}\n\nif (!IsotopeNode.prototype.setStyles) {\n\tIsotopeNode.prototype.onCreate.push((node, config) => {\n\t\tif (config.styles) {\n\t\t\tif (typeof config.styles === \"function\") {\n\t\t\t\tnode.styles = config.styles;\n\t\t\t} else {\n\t\t\t\tnode.setStyles(config.styles);\n\t\t\t}\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.styles) {\n\t\t\tnode.setStyles(node.styles(node));\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\tgetStyle<P extends keyof StyleProperties>(\n\t\t\tthis: IsotopeNode,\n\t\t\tproperty: P\n\t\t): StyleProperties[P] | undefined {\n\t\t\tconst { style } = this.element;\n\n\t\t\treturn style ? style[property] : style;\n\t\t},\n\t\t/** @private */\n\t\tsetStyle<P extends keyof StyleProperties>(\n\t\t\tthis: IsotopeNode,\n\t\t\tproperty: P,\n\t\t\tvalue: StyleProperties[P]\n\t\t): IsotopeNode {\n\t\t\tconst { style } = this.element;\n\n\t\t\tif (style) {\n\t\t\t\tstyle[property] = `${value}${typeof value === \"number\" ? \"px\" : \"\"}` as any;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t},\n\t\t/** @private */\n\t\tsetStyles(this: IsotopeNode, styles: StyleProperties): IsotopeNode {\n\t\t\tObject.entries(styles).forEach(\n\t\t\t\t([property, value]: [keyof StyleProperties, string | number]) => {\n\t\t\t\t\tthis.setStyle(property, value);\n\t\t\t\t}\n\t\t\t);\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","interface Change {\n\tid: SimpleItem;\n\titem?: Item;\n\tposition?: number;\n\ttype: \"add\" | \"remove\" | \"move\";\n}\n\ninterface DiffingData {\n\tchanges: Change[];\n\tindex: number;\n\tsource: SimpleItem[];\n\tsourceInput: Item[];\n\ttarget: SimpleItem[];\n\ttargetInput: Item[];\n}\n\ninterface MoveData {\n\tleft: SimpleItem | null;\n\tright: SimpleItem | null;\n}\n\ntype SimpleItem = string | number;\n\ntype Item = string | number | { id: string | number };\n\n/**\n * Creates the Diffing loop data object.\n *\n * @param sourceInput - Original, source Item array.\n * @param targetInput - Target Item array.\n * @returns - Diffing loop data object.\n */\nconst createData = (sourceInput: Item[], targetInput: Item[]): DiffingData => ({\n\tchanges: [],\n\tindex: 0,\n\tsource: sourceInput.map((item) => `${typeof item === \"object\" ? item.id : item}`),\n\tsourceInput,\n\ttarget: targetInput.map((item) => `${typeof item === \"object\" ? item.id : item}`),\n\ttargetInput\n});\n/**\n * Checks if the diffing loop should be run.\n *\n * @param data - Diffing loop data.\n * @returns - If the diffing loop should be run.\n */\nconst shouldLoop = ({ index, source, target }: DiffingData): boolean => {\n\treturn (\n\t\tsource.length > 0 &&\n\t\ttarget.length > 0 &&\n\t\t(index <= source.length || index <= target.length)\n\t);\n};\n/**\n * Trims the diffed arrays from both sides if edge items are equal.\n *\n * @param data - Diffing loop data.\n * @returns - If arrays were trimmed.\n */\nconst trim = ({ source, target }: DiffingData): boolean => {\n\tconst [sourceStart] = source;\n\tconst sourceEnd = source[source.length - 1];\n\tconst [targetStart] = target;\n\tconst targetEnd = target[target.length - 1];\n\n\tlet trimmed = false;\n\n\tif (sourceStart === targetStart) {\n\t\tsource.shift();\n\t\ttarget.shift();\n\t\ttrimmed = true;\n\t}\n\n\tif (sourceEnd === targetEnd) {\n\t\tsource.pop();\n\t\ttarget.pop();\n\t\ttrimmed = true;\n\t}\n\n\treturn trimmed;\n};\n/**\n * Detect whether the items should be moved to the opposite site of the array.\n *\n * @param data - Diffing loop data.\n * @returns - Which item should be moved to left and which to right.\n */\nconst prepareMove = ({ index, source, target }: DiffingData): MoveData => {\n\tconst sourceStart = source[index];\n\tconst sourceEnd = source[source.length - 1 - index];\n\tconst [targetStart] = target;\n\tconst targetEnd = target[target.length - 1];\n\tconst moveLeft = sourceEnd === targetStart;\n\tconst moveRight = sourceStart === targetEnd;\n\tconst itemToLeft = moveLeft ? source.splice(source.length - 1 - index, 1)[0] : null;\n\tconst itemToRight = moveRight ? source.splice(index, 1)[0] : null;\n\n\treturn {\n\t\tleft: itemToLeft,\n\t\tright: itemToRight\n\t};\n};\n/**\n * Move the specified items to the opposite site of the array.\n *\n * @param data - Diffing loop data.\n * @param itemToLeft - Item to be moved to the left end.\n * @param itemToRight - Item to be moved to the right end.\n */\nconst move = (\n\t{ changes, source }: DiffingData,\n\titemToLeft: SimpleItem | null,\n\titemToRight: SimpleItem | null\n): void => {\n\tif (itemToRight !== null) {\n\t\tsource.push(itemToRight);\n\t\tchanges.push({\n\t\t\tid: itemToRight,\n\t\t\ttype: \"move\"\n\t\t});\n\t}\n\n\tif (itemToLeft !== null) {\n\t\tsource.splice(0, 0, itemToLeft);\n\t\tchanges.push({\n\t\t\tid: itemToLeft,\n\t\t\ttype: \"move\"\n\t\t});\n\t}\n};\n/**\n * Adds the new items from diffed arrays.\n *\n * @param data - Diffing loop data.\n */\nconst add = ({ changes, target }: DiffingData): void => {\n\ttarget.splice(0).forEach((id) => {\n\t\tchanges.push({\n\t\t\tid,\n\t\t\ttype: \"add\"\n\t\t});\n\t});\n};\n/**\n * Removes the previous items from diffed arrays.\n *\n * @param data - Diffing loop data.\n */\nconst remove = ({ changes, source }: DiffingData): void => {\n\tsource.splice(0).forEach((id) => {\n\t\tchanges.push({\n\t\t\tid,\n\t\t\ttype: \"remove\"\n\t\t});\n\t});\n};\n/**\n * Fills the remaining data required by specific changes.\n *\n * @param data - Diffing loop data.\n */\nconst fill = ({ changes, targetInput }: DiffingData): void => {\n\tchanges.forEach((change) => {\n\t\tconst id = `${change.id}`;\n\t\tconst { type } = change;\n\n\t\tif (type === \"add\" || type === \"move\") {\n\t\t\tconst index = targetInput.findIndex((item) => {\n\t\t\t\treturn typeof item === \"object\" ? `${item.id}` === id : `${item}` === id;\n\t\t\t});\n\n\t\t\tif (type === \"add\") {\n\t\t\t\tchange.item = targetInput[index];\n\t\t\t}\n\n\t\t\tchange.position = index;\n\t\t}\n\t});\n};\n/**\n * Detects changes made between 2 Item arrays.\n *\n * @param sourceInput - Original, source Item array.\n * @param targetInput - Target Item array.\n * @returns - Changes that differ the second array from the first one.\n */\nconst detectChanges = (sourceInput: Item[], targetInput: Item[]): Change[] => {\n\tconst data = createData(sourceInput, targetInput);\n\n\twhile (shouldLoop(data)) {\n\t\tif (trim(data)) {\n\t\t\tdata.index = 0;\n\t\t\tcontinue;\n\t\t}\n\n\t\tconst { left, right } = prepareMove(data);\n\n\t\tif (left !== null || right !== null) {\n\t\t\tmove(data, left, right);\n\t\t\tdata.index = 0;\n\t\t} else {\n\t\t\tdata.index += 1;\n\t\t}\n\t}\n\n\tadd(data);\n\tremove(data);\n\tfill(data);\n\n\treturn data.changes;\n};\n\nexport { detectChanges };\n","import { Indexable } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\nimport { detectChanges } from \"../utils\";\n\ninterface MapData<\n\tS extends Indexable,\n\tC extends Indexable,\n\tI extends MappableItem = MappableItem\n> {\n\titems: Exclude<Mappable<S, C, I>, any[]>;\n\tcreateItem(item: any, node: IsotopeNode<S, C>, index: number): IsotopeNode | void;\n}\n\ntype MappableItem = string | number | { id: string | number };\n\ntype Mappable<\n\tS extends Indexable,\n\tC extends Indexable,\n\tI extends MappableItem = MappableItem\n> = I[] | keyof S | ((node: IsotopeNode<S, C>) => I[]);\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\tmapData?: MapData<S, C> | null;\n\t\t/**\n\t\t * Maps the provided data to a rendered Nodes list.\n\t\t *\n\t\t * @param items - Items to be mapped.\n\t\t * @param createItem - Rendering function to be used to render mapped items.\n\t\t * @returns - The Node.\n\t\t */\n\t\tmap<I extends MappableItem>(\n\t\t\titems: Mappable<S, C, I>,\n\t\t\tcreateItem: (item: I, node: this, index: number) => IsotopeNode | void\n\t\t): this;\n\t}\n}\n\nif (!IsotopeNode.prototype.map) {\n\t/**\n\t * Handles Nodes map update.\n\t *\n\t * @param node - The parent Node.\n\t * @param items - New items to be mapped.\n\t */\n\tconst handleMapUpdate = (node: IsotopeNode, items: MappableItem[]): void => {\n\t\tconst data = node.mapData!;\n\t\tconst changes = detectChanges(\n\t\t\t(node.linked as Array<{ id: string | number }>) || [],\n\t\t\titems\n\t\t);\n\n\t\tchanges.forEach(({ id, item, position = 0, type }, index) => {\n\t\t\tif (type === \"add\") {\n\t\t\t\tconst child = data.createItem(item, node, index);\n\n\t\t\t\tif (child) {\n\t\t\t\t\tchild.id = `${id}`;\n\t\t\t\t\tnode.link(child, position);\n\t\t\t\t\tchild.move(position);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst child = node.linked!.find((linked) => linked.id === id);\n\n\t\t\t\tif (child) {\n\t\t\t\t\tif (type === \"remove\") {\n\t\t\t\t\t\tchild.remove();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchild.move(position);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Handles the Nodes map creation.\n\t *\n\t * @param node - The parent Node.\n\t * @param items - Items to be mapped.\n\t */\n\tconst handleMapCreation = (node: IsotopeNode, items: MappableItem[]): void => {\n\t\tconst data = node.mapData!;\n\n\t\titems.forEach((item, index) => {\n\t\t\tconst child = data.createItem(item, node, index);\n\n\t\t\tif (child) {\n\t\t\t\tchild.id = `${typeof item === \"object\" ? item.id : item}`;\n\t\t\t\tnode.link(child);\n\t\t\t}\n\t\t});\n\t};\n\t/**\n\t * Processes the provided Node's map child tree.\n\t *\n\t * @param node - Node to be processed.\n\t */\n\tconst processMap = (node: IsotopeNode): void => {\n\t\tif (node.mapData) {\n\t\t\tconst data = node.mapData;\n\t\t\tconst items: MappableItem[] =\n\t\t\t\ttypeof data.items === \"function\" ? data.items(node) : node.getState(data.items);\n\n\t\t\tif (node.linked) {\n\t\t\t\thandleMapUpdate(node, items);\n\t\t\t} else {\n\t\t\t\thandleMapCreation(node, items);\n\t\t\t}\n\t\t}\n\t};\n\n\tIsotopeNode.prototype.onClean.push((node) => {\n\t\tif (node.mapData) {\n\t\t\tnode.mapData = null;\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.mapData) {\n\t\t\tprocessMap(node);\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\tmap(\n\t\t\tthis: IsotopeNode,\n\t\t\titems: Mappable<any, any>,\n\t\t\tcreateItem: (item: any, node: IsotopeNode, index: number) => IsotopeNode | void\n\t\t): IsotopeNode {\n\t\t\tthis.clean();\n\n\t\t\tif (Array.isArray(items)) {\n\t\t\t\titems.forEach((item, index) => {\n\t\t\t\t\tcreateItem(item, this, index);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tthis.mapData = {\n\t\t\t\t\tcreateItem,\n\t\t\t\t\titems\n\t\t\t\t};\n\t\t\t\tprocessMap(this);\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","import { Indexable } from \"../declarations\";\nimport { IsotopeNode } from \"../node\";\n\ntype TextData<S extends Indexable, C extends Indexable> = (\n\tnode: IsotopeNode<S, C>\n) => string;\n\ndeclare module \"../node\" {\n\tinterface IsotopeNode<S extends Indexable = any, C extends Indexable = any> {\n\t\ttextData?: TextData<S, C> | null;\n\t\t/**\n\t\t * Sets the Node's element text.\n\t\t *\n\t\t * @param text - Text to be set.\n\t\t * @returns - The Node.\n\t\t */\n\t\ttext(text: TextData<S, C> | string): this;\n\t}\n}\n\nif (!IsotopeNode.prototype.text) {\n\t/**\n\t * Processes the provided Node's text child tree.\n\t *\n\t * @param node - Node to be processed.\n\t */\n\tconst processText = (node: IsotopeNode): void => {\n\t\tif (node.textData) {\n\t\t\tconst data = node.textData(node);\n\n\t\t\tif (data !== node.element.textContent) {\n\t\t\t\tnode.element.textContent = data;\n\t\t\t}\n\t\t}\n\t};\n\n\tIsotopeNode.prototype.onClean.push((node) => {\n\t\tif (node.textData) {\n\t\t\tnode.textData = null;\n\t\t}\n\t});\n\tIsotopeNode.prototype.onProcess.push((node) => {\n\t\tif (node.textData) {\n\t\t\tprocessText(node);\n\t\t}\n\t});\n\tObject.assign(IsotopeNode.prototype, {\n\t\t/** @private */\n\t\ttext(this: IsotopeNode, text: TextData<any, any> | string): IsotopeNode {\n\t\t\tthis.clean();\n\n\t\t\tif (typeof text === \"function\") {\n\t\t\t\tthis.textData = text;\n\t\t\t\tprocessText(this);\n\t\t\t} else {\n\t\t\t\tthis.element.textContent = text;\n\t\t\t}\n\n\t\t\treturn this;\n\t\t}\n\t});\n}\n","import { Directive, IsotopeNode, IsotopeNodeConfig } from \"../../node\";\nimport { Indexable } from \"../../declarations\";\n\ntype Child = <S extends Indexable = any, C extends Indexable = any>(\n\tconfig?:\n\t\t| IsotopeNodeConfig<S, C>\n\t\t| string\n\t\t| Directive<S, C, void>\n\t\t| Array<Directive<S, C, void>>\n) => IsotopeNode<S, C>;\n\n/**\n * Registers new Node child function.\n *\n * @param name - Name for the child.\n */\nconst registerChild = (name: string): void => {\n\t/** @private */\n\tif (!IsotopeNode.prototype[name as keyof typeof IsotopeNode.prototype]) {\n\t\tIsotopeNode.prototype[name as keyof typeof IsotopeNode.prototype] = function (\n\t\t\tthis: IsotopeNode,\n\t\t\tconfig?: IsotopeNodeConfig<any, any> | string\n\t\t) {\n\t\t\treturn this.child(name, config);\n\t\t};\n\t}\n};\n\nexport { Child, registerChild };\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tblockquote: Child;\n\t\tdd: Child;\n\t\tdiv: Child;\n\t\tdl: Child;\n\t\tdt: Child;\n\t\tfigcaption: Child;\n\t\tfigure: Child;\n\t\thr: Child;\n\t\tli: Child;\n\t\tmain: Child;\n\t\tol: Child;\n\t\tp: Child;\n\t\tpre: Child;\n\t\tul: Child;\n\t}\n}\n\nconst nodes = [\n\t\"blockquote\",\n\t\"dd\",\n\t\"div\",\n\t\"dl\",\n\t\"dt\",\n\t\"figcaption\",\n\t\"figure\",\n\t\"hr\",\n\t\"li\",\n\t\"main\",\n\t\"ol\",\n\t\"p\",\n\t\"pre\",\n\t\"ul\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tembed: Child;\n\t\tiframe: Child;\n\t\tobject: Child;\n\t\tparam: Child;\n\t\tpicture: Child;\n\t\tsource: Child;\n\t}\n}\n\nconst nodes = [\"embed\", \"iframe\", \"object\", \"param\", \"picture\", \"source\"];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tbutton: Child;\n\t\tdatalist: Child;\n\t\tfieldset: Child;\n\t\tform: Child;\n\t\tinput: Child;\n\t\tlabel: Child;\n\t\tlegend: Child;\n\t\tmeter: Child;\n\t\toptgroup: Child;\n\t\toption: Child;\n\t\toutput: Child;\n\t\tprogress: Child;\n\t\tselect: Child;\n\t\ttextarea: Child;\n\t}\n}\n\nconst nodes = [\n\t\"button\",\n\t\"datalist\",\n\t\"fieldset\",\n\t\"form\",\n\t\"input\",\n\t\"label\",\n\t\"legend\",\n\t\"meter\",\n\t\"optgroup\",\n\t\"option\",\n\t\"output\",\n\t\"progress\",\n\t\"select\",\n\t\"textarea\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tdetails: Child;\n\t\tdialog: Child;\n\t\tmenu: Child;\n\t\tsummary: Child;\n\t\tcanvas: Child;\n\t\tscript: Child;\n\t\tnoscript: Child;\n\t\tslot: Child;\n\t\ttemplate: Child;\n\t}\n}\n\nconst nodes = [\n\t\"details\",\n\t\"dialog\",\n\t\"menu\",\n\t\"summary\",\n\t\"canvas\",\n\t\"script\",\n\t\"noscript\",\n\t\"slot\",\n\t\"template\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tarea: Child;\n\t\taudio: Child;\n\t\timg: Child;\n\t\ttrack: Child;\n\t\tvideo: Child;\n\t}\n}\n\nconst nodes = [\"area\", \"audio\", \"img\", \"track\", \"video\"];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\taddress: Child;\n\t\tarticle: Child;\n\t\taside: Child;\n\t\tfooter: Child;\n\t\theader: Child;\n\t\th1: Child;\n\t\th2: Child;\n\t\th3: Child;\n\t\th4: Child;\n\t\th5: Child;\n\t\th6: Child;\n\t\thgroup: Child;\n\t\tmain: Child;\n\t\tnav: Child;\n\t\tsection: Child;\n\t}\n}\n\nconst nodes = [\n\t\"address\",\n\t\"article\",\n\t\"aside\",\n\t\"footer\",\n\t\"header\",\n\t\"h1\",\n\t\"h2\",\n\t\"h3\",\n\t\"h4\",\n\t\"h5\",\n\t\"h6\",\n\t\"hgroup\",\n\t\"main\",\n\t\"nav\",\n\t\"section\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tcaption: Child;\n\t\tcol: Child;\n\t\tcolgroup: Child;\n\t\ttable: Child;\n\t\ttbody: Child;\n\t\ttd: Child;\n\t\ttfoot: Child;\n\t\tth: Child;\n\t\tthead: Child;\n\t\ttr: Child;\n\t}\n}\n\nconst nodes = [\n\t\"caption\",\n\t\"col\",\n\t\"colgroup\",\n\t\"table\",\n\t\"tbody\",\n\t\"td\",\n\t\"tfoot\",\n\t\"th\",\n\t\"thead\",\n\t\"tr\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { Child, registerChild } from \"./register\";\n\ndeclare module \"../../node\" {\n\tinterface IsotopeNode {\n\t\tdel: Child;\n\t\tins: Child;\n\t\ta: Child;\n\t\tabbr: Child;\n\t\tb: Child;\n\t\tbdi: Child;\n\t\tbdo: Child;\n\t\tbr: Child;\n\t\tcite: Child;\n\t\tcode: Child;\n\t\tdata: Child;\n\t\tdfn: Child;\n\t\tem: Child;\n\t\ti: Child;\n\t\tkbd: Child;\n\t\tmark: Child;\n\t\tq: Child;\n\t\trb: Child;\n\t\trp: Child;\n\t\trt: Child;\n\t\trtc: Child;\n\t\truby: Child;\n\t\ts: Child;\n\t\tsamp: Child;\n\t\tsmall: Child;\n\t\tspan: Child;\n\t\tstrong: Child;\n\t\tsub: Child;\n\t\tsup: Child;\n\t\ttime: Child;\n\t\tu: Child;\n\t\tvar: Child;\n\t\twbr: Child;\n\t}\n}\n\nconst nodes = [\n\t\"del\",\n\t\"ins\",\n\t\"a\",\n\t\"abbr\",\n\t\"b\",\n\t\"bdi\",\n\t\"bdo\",\n\t\"br\",\n\t\"cite\",\n\t\"code\",\n\t\"data\",\n\t\"dfn\",\n\t\"em\",\n\t\"i\",\n\t\"kbd\",\n\t\"mark\",\n\t\"q\",\n\t\"rb\",\n\t\"rp\",\n\t\"rt\",\n\t\"rtc\",\n\t\"ruby\",\n\t\"s\",\n\t\"samp\",\n\t\"small\",\n\t\"span\",\n\t\"strong\",\n\t\"sub\",\n\t\"sup\",\n\t\"time\",\n\t\"u\",\n\t\"var\",\n\t\"wbr\"\n];\n\nnodes.forEach((name) => {\n\tregisterChild(name);\n});\n","import { IsotopeNode } from \"../node\";\n\ninterface IsotopeViewConfig {\n\tattach?: boolean;\n\tclean?: boolean;\n}\n\n/**\n * Creates a DOM View.\n *\n * @param element - Element to append to.\n * @param config - DOM View config.\n * @returns - The created top-level Node.\n */\nconst createDOMView = (element: Element, config?: IsotopeViewConfig): IsotopeNode => {\n\tif (IsotopeNode.prototype.customDOM) {\n\t\tIsotopeNode.prototype.customDOM = null;\n\t}\n\n\tif (!config || (config && config.clean && !config.attach)) {\n\t\telement.textContent = \"\";\n\t}\n\n\treturn new IsotopeNode(element, config);\n};\n\nexport { createDOMView };\n","import { CustomEvent } from \"../../declarations\";\nimport { IsotopeNode } from \"../../node\";\nimport { StringElement } from \"./element\";\n\n/**\n * Creates a String View.\n *\n * @param tag - Tag for the top-level Node.\n * @returns - The created top-level Node.\n */\nconst createStringView = (tag: string): IsotopeNode => {\n\tif (!IsotopeNode.prototype.customDOM) {\n\t\tIsotopeNode.prototype.customDOM = {\n\t\t\t/** @private */\n\t\t\tcreateElement(tag: string): StringElement {\n\t\t\t\treturn new StringElement(tag);\n\t\t\t},\n\t\t\t/** @private */\n\t\t\tcreateEvent(type: string): CustomEvent {\n\t\t\t\treturn { type };\n\t\t\t}\n\t\t};\n\t}\n\n\treturn new IsotopeNode(tag);\n};\n\nexport { createStringView };\n"],"names":["IsotopeNode","[object Object]","element","config","this","getElement","textContent","Array","isArray","$","attach","childIndex","autoLink","state","context","onCreate","forEach","callback","process","directives","directive","value","tag","shouldAttach","attachTarget","children","node","appendChild","Object","assign","link","linked","onClean","event","data","dispatchEvent","customDOM","createEvent","Event","key","position","nodeLinkup","linkup","splice","indexOf","push","upperLinked","referenceNode","insertBefore","handler","options","removeEventListener","addEventListener","parentElement","removeChild","emit","namespace","createElement","document","createElementNS","onProcess","prototype","StringElement","add","tokens","classes","contains","token","includes","remove","tagName","type","listener","events","newChild","slice","handleEvent","qualifiedName","attributes","refChild","index","oldChild","$textContent","content","map","child","join","styles","entries","style","property","replace","match","toLowerCase","name","setAttribs","attribs","attrib","getAttribute","setAttribute","removeAttribute","setAttrib","setClasses","className","classList","addClass","removeClass","setStyles","setStyle","if","processConditional","conditionalData","condition","processedCondition","Boolean","getState","previous","onTrue","onFalse","clean","shouldLoop","source","target","length","trim","sourceStart","sourceEnd","targetStart","targetEnd","trimmed","shift","pop","prepareMove","moveRight","left","right","move","changes","itemToLeft","itemToRight","id","handleMapUpdate","items","mapData","sourceInput","targetInput","item","createData","change","findIndex","fill","detectChanges","createItem","find","handleMapCreation","processMap","text","processText","textData","registerChild"],"mappings":"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,SACA,QACA,WACA,SACA,SACA,WACA,SACA,YAGK9E,QAAS8E,IACdiE,EAAcjE,KCvBD,CACb,UACA,SACA,OACA,UACA,SACA,SACA,WACA,OACA,YAGK9E,QAAS8E,IACdiE,EAAcjE,KCjBD,CAAC,OAAQ,QAAS,MAAO,QAAS,SAE1C9E,QAAS8E,IACdiE,EAAcjE,KCOD,CACb,UACA,UACA,QACA,SACA,SACA,KACA,KACA,KACA,KACA,KACA,KACA,SACA,OACA,MACA,WAGK9E,QAAS8E,IACdiE,EAAcjE,KCxBD,CACb,UACA,MACA,WACA,QACA,QACA,KACA,QACA,KACA,QACA,MAGK9E,QAAS8E,IACdiE,EAAcjE,KCSD,CACb,MACA,MACA,IACA,OACA,IACA,MACA,MACA,KACA,OACA,OACA,OACA,MACA,KACA,IACA,MACA,OACA,IACA,KACA,KACA,KACA,MACA,OACA,IACA,OACA,QACA,OACA,SACA,MACA,MACA,OACA,IACA,MACA,OAGK9E,QAAS8E,IACdiE,EAAcjE,qCC/DO,EAAC5F,EAAkBC,KACpCH,EAAY6D,UAAUzB,YACzBpC,EAAY6D,UAAUzB,UAAY,QAG9BjC,GAAWA,GAAUA,EAAOoH,QAAUpH,EAAOO,UACjDR,EAAQI,YAAc,IAGhB,IAAIN,EAAYE,EAASC,wBCbR,CAACmB,IACpBtB,EAAY6D,UAAUzB,YAC1BpC,EAAY6D,UAAUzB,UAAY,CAEjCqB,cAAcnC,GACN,IAAIwC,EAAcxC,GAG1Be,YAAYkC,IACJ,CAAEA,KAAAA,MAKL,IAAIvE,EAAYsB"}